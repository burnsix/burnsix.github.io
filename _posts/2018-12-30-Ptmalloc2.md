---
title: Ptmalloc 2
date: 2019-12-30
---

2번 째 드디어 제일 중요한 ptmalloc에서의 할당과 해제 그리고 재 할당! + 보안 검사까지 알아보도록 하자 두근두근

## Ptmalloc의 할당과 해제

### __libc_free

ptmalloc의 할당과 유사하게 \_int_free는 pamalloc deallocation의 내부 구현이며 래퍼 함수 \__libc_free를 통해서 호출된다. __libc_malloc과는 다르게 \_int_free를 call하기 전에 해야 할 몇 가지 추가 단계가 있다.

```c
void __libc_free (void *mem)
{
  mstate ar_ptr;
  mchunkptr p;                          /* chunk corresponding to mem */
  p = mem2chunk (mem);
  if (chunk_is_mmapped (p))                       /* release mmapped memory. */
  {
      /* see if the dynamic brk/mmap threshold needs adjusting */
      if (!mp_.no_dyn_threshold
          && p->size > mp_.mmap_threshold
          && p->size > DEFAULT_MMAP_THRESHOLD_MAX)
      {
          mp_.mmap_threshold = chunksize (p);
          mp_.trim_threshold = 2 * mp_.mmap_threshold;
          LIBC_PROBE (memory_mallopt_free_dyn_thresholds, 2,
                      mp_.mmap_threshold, mp_.trim_threshold);
      }
      munmap_chunk (p);
      return;
  }
 
  ar_ptr = arena_for_chunk (p);
  _int_free (ar_ptr, p, 0);
}
libc_hidden_def (__libc_free)
```

\__libc_free 함수는 먼저 현재 chunk가 mmap을 통해서 직접 할당하는지 확인한다. mmap을 통해서 할당된 chunk라면 deallocator는 __libc_free 함수를 호출하지 않고 chunk를 직접 해제 한다.

그 다음 현재 chunk가 main_arena에 속하는지 확인한다. 그렇지 않으면 arena pointer를 먼저 검색한다. arena pointer를 얻으려면 chunk pointer는 x86 시스템에서 0xfff00000과 and 연산을 하고 x64 시스템에서는 chunk pointer와 0xfffffffffc000000을 and 연산 한다.

### Unlink

unlink는 heap chunk 관리에서 매우 중요한 기능이다. 파트 1에서 설명한 것처럼 fastbin chunk를 제외한 모든 해제 된 chunk는 doubly linked list를 통해 관리 되는데. unlink (P,BK,FD)는 현재의 doubly linked list목록에서 chunk P를 제거 한다.

### Free internal

일반적으로 3가지 단계로 나눌 수 있다.

1. 해제 된 chunk가 fastbin에 속하면 deallocator가 chunk를 fastbin 에 삽입한다.
2. 해제 된 chunk의 크기가 fast size 보다 크면 chunk를 먼저 처리하고 처리 된 chunk를 해당 chunk에 삽입한다.
3. 3번 째는 추가 단계이다. 해제 된 chunk의 크기가 임계 값(0x10000)보다 크면 해제 된 chunk를 가능한 많이 통합하려고 시도한다.

![20171211002](/Users/bskim/Desktop/20171211002.png)

이것 또한 그림은 일단 박아두겠당..

<br>

### Fastbin chunk deallocation

```c
/* We might not have a lock at this point and concurrent modifications
   of system_mem might have let to a false positive.  Redo the test
   after getting the lock.  */
if (chunk_at_offset (p, size)->size <= 2 * SIZE_SZ               || chunksize (chunk_at_offset (p, size)) >= av->system_mem;)
{
    errstr = "free(): invalid next size (fast)";
    goto errout;
}
if (! have_lock)
{
    (void)mutex_unlock(&av->mutex);
    locked = 0;
}
 
free_perturb (chunk2mem(p), size - 2 * SIZE_SZ);
 
set_fastchunks(av);
unsigned int idx = fastbin_index(size);
fb = &fastbin (av, idx);
 
/* Atomically link P to its fastbin: P->FD = *FB; *FB = P;  */
mchunkptr old = *fb, old2;
unsigned int old_idx = ~0u;
do
{
     /* Check that the top of the bin is not the record we are going to add
    (i.e., double free).  */
if (__builtin_expect (old == p, 0))
     {
    errstr = "double free or corruption (fasttop)";
    goto errout;
     }
/* Check that size of fastbin chunk at the top is the same as
    size of the chunk that we are adding.  We can dereference OLD
    only if we have the lock, otherwise it might have already been
    deallocated.  See use of OLD_IDX below for the actual check.  */
     if (have_lock && old != NULL)
        old_idx = fastbin_index(chunksize(old));
     p->fd = old2 = old;
}
while ((old = catomic_compare_and_exchange_val_rel (fb, p, old2)) != old2);
```

deallocator는 먼저 fastbin에서 해제 된 chunk의 크기와 첫 번째 chunk(old)의 유효성을 검사한다. 검사에 통과하면 해제 된 chunk를 fastbin에 새로운 첫 번째 chunk로 삽입하고 fd pointer는 old를 가리 키도록 설정한다.

<br>

### Smallbin chunk deallocation

```c
nextchunk = chunk_at_offset(p, size);
 
/* Lightweight tests: check whether the block is already the
   top block.  */
if (__glibc_unlikely (p == av->top))
{
    errstr = "double free or corruption (top)";
    goto errout;
}
/* Or whether the next chunk is beyond the boundaries of the arena.  */
if (__builtin_expect (contiguous (av)
      && (char *) nextchunk>= ((char *) av->top + chunksize(av->top)), 0))
{
    errstr = "double free or corruption (out)";
    goto errout;
}
/* Or whether the block is actually not marked used.  */
if (__glibc_unlikely (!prev_inuse(nextchunk)))
{
    errstr = "double free or corruption (!prev)";
    goto errout;
}
 
nextsize = chunksize(nextchunk);
if (__builtin_expect (nextchunk->size <= 2 * SIZE_SZ, 0)            || __builtin_expect (nextsize >= av->system_mem, 0))
{
     errstr = "free(): invalid next size (normal)";
     goto errout;
}
 
free_perturb (chunk2mem(p), size - 2 * SIZE_SZ);
 
/* consolidate backward */
if (!prev_inuse(p)) {
     prevsize = p->prev_size;
     size += prevsize;
     p = chunk_at_offset(p, -((long) prevsize));
     unlink(p, bck, fwd);
}
 
if (nextchunk != av->top) {
/* get and clear inuse bit */
nextinuse = inuse_bit_at_offset(nextchunk, nextsize);
 
      /* consolidate forward */
      if (!nextinuse) {
        unlink(nextchunk, bck, fwd);
        size += nextsize;
      } else
        clear_inuse_bit_at_offset(nextchunk, 0);
 
      /*
        Place the chunk in unsorted chunk list. Chunks are
        not placed into regular bins until after they have
        been given one chance to be used in malloc.
      */
 
      bck = unsorted_chunks(av);
      fwd = bck->fd;
      if (__glibc_unlikely (fwd->bk != bck))
      {
      errstr = "free(): corrupted unsorted chunks";
      goto errout;
      }
      p->fd = fwd;
      p->bk = bck;
      if (!in_smallbin_range(size))
      {
      p->fd_nextsize = NULL;
      p->bk_nextsize = NULL;
      }
      bck->fd = p;
      fwd->bk = p;
 
      set_head(p, size | PREV_INUSE);
      set_foot(p, size);
 
      check_free_chunk(av, p);
}
else {
      size += nextsize;
      set_head(p, size | PREV_INUSE);
      av->top = p;
      check_chunk(av, p);
}
```

1. 인접한 이전 chunk가 해제 된 경우, 현재 chunk를 이전 chunk와 병합한다. 이전 chunk의 연결을 해제하고 새로 병합된 chunk를 현재 chunk로 설정한다.
2. 다음 인접한 chunk가 top chunk일 경우, 현재 chunk를 top chunk로 병합한다.
3. 인접한 chunk가 free chunk일 경우, 현재 chunk를 다음 인접한 chunk와 병합한다. 다음 인접한 chunk의 연결을 해제하고 새로 병합된 chunk를 현재 chunk로 설정한다. 인접한 다음 chunk가 해제되지 않은 경우, 인접한 다음 chunk의 P bit를 설정 해제 한다.
4. 현재 chunk를 unsorted bin에 삽입한다.

 <br>

### Reduce Fragmented chunks

```c
if ((unsigned long)(size) >= FASTBIN_CONSOLIDATION_THRESHOLD) {
    if (have_fastchunks(av))
    malloc_consolidate(av);
 
    if (av == &main_arena) {
#ifndef MORECORE_CANNOT_TRIM
    if ((unsigned long)(chunksize(av->top)) >=
        (unsigned long)(mp_.trim_threshold))
      systrim(mp_.top_pad, av);
#endif
    } else {
    /* Always try heap_trim(), even if the top chunk is not
       large, because the corresponding heap might go away.  */
    heap_info *heap = heap_for_ptr(top(av));
 
    assert(heap->ar_ptr == av);
    heap_trim(heap, mp_.top_pad);
    }
}
```

해제 된 chunk의 크기가 FASTBIN_CONSOLIDATION_THRESHOLD를 초과할 경우 deallocator는 가능한 한 으로 fastbin chunk를 병합한다. 

<br>

## Ptmalloc Reallocation

realloc 함수는 대상 chunk의 크기를 조정하고 요청된 크기의 새 chunk pointer를 반환 한다. 재 할당의 첫 번째 단계는 원하는 chunk를 heap에서 추출한다. 두 번째 단계는 나머지 부분에 대한 후 처리를 한다.

![20171211003](/Users/bskim/Desktop/20171211003.png)

마찬가지로 그림 박아두기..

### Resize chunk

```c
if ((unsigned long) (oldsize) >= (unsigned long) (nb))
{
     /* already big enough; split below */
     newp = oldp;
     newsize = oldsize;
}
else
{
     /* Try to expand forward into top */
     if (next == av->top &&
         (unsigned long) (newsize = oldsize + nextsize) >=
         (unsigned long) (nb + MINSIZE))
     {
         set_head_size (oldp, nb | (av != &main_arena ? NON_MAIN_ARENA : 0));
         av->top = chunk_at_offset (oldp, nb);
         set_head (av->top, (newsize - nb) | PREV_INUSE);
         check_inuse_chunk (av, oldp);
         return chunk2mem (oldp);
      }
 
      /* Try to expand forward into next chunk;  split off remainder below */
      else if (next != av->top &&
               !inuse (next) &&
               (unsigned long) (newsize = oldsize + nextsize) >= (unsigned long) (nb))
      {
          newp = oldp;
          unlink (next, bck, fwd);
      }
 
      /* allocate, copy, free */
      else
      {
          newmem = _int_malloc (av, nb - MALLOC_ALIGN_MASK);
          if (newmem == 0)
            return 0; /* propagate failure */
 
          newp = mem2chunk (newmem);
          newsize = chunksize (newp);
 
          /*
             Avoid copy if newp is next chunk after oldp.
           */
          if (newp == next)
          {
              newsize += oldsize;
              newp = oldp;
          }
          else
          {
              /*code of copying data*/
              _int_free (av, oldp, 1);
              check_inuse_chunk (av, newp);
              return chunk2mem (newp);
          }
      }
}
```

1. 요청 된 크기가 현재 크기보다 작은 경우 후 처리로 이동한다. (재할당)
2. 다음 chunk가 top chunk 인 경우, top chunk에서 하나의 chunk를 분할하고 현재 chunk를 새 chunk와 병합하여 반환한다.
3. 다음 인접 chunk가 top chunk가 아닌 상황에선, 다음 인접 chunk가 해제되고 현재 chunk 및 다음 인접 chunk의 크기 합이 요구 된 크기보다 크다면 다음 chunk를 연결 해제하고 현재 chunk과 다음 chunk를 병합하고 병합 된 chunk를 현재 chunk로 설정한다.
4. 요청 된 크기의 새 chunk를 할당한다. 새 chunk가 현재 chunk의 다음 인접 chunk일 경우, 현재 chunk를 새 chunk와 병합하고 후 처리로 이동한다. 그렇지 않다면 현재 chunk를 비우고 새로 할당 된 chunk를 반환한다.

### Post-processing

```c
remainder_size = newsize - nb;
if (remainder_size < MINSIZE)   /* not enough extra to split off */
{
    set_head_size (newp, newsize | (av != &main_arena ? NON_MAIN_ARENA : 0));
    set_inuse_bit_at_offset (newp, newsize);
}
else   /* split remainder */
{
    remainder = chunk_at_offset (newp, nb);
    set_head_size (newp, nb | (av != &main_arena ? NON_MAIN_ARENA : 0));
    set_head (remainder, remainder_size | PREV_INUSE |
              (av != &main_arena ? NON_MAIN_ARENA : 0));
    /* Mark remainder as inuse so free() won't complain */
    set_inuse_bit_at_offset (remainder, remainder_size);
    _int_free (av, remainder, 1);
}
check_inuse_chunk (av, newp);
return chunk2mem (newp);
```

후 처리! (재 할당 후)

1. 나머지 chunk의 크기가 최소 크기보다 작으면(0x10 , 0x20) chunk를 분할하지 않고 전체 chunk를 반환 값으로 반환한다.
2. 그렇지 않으면, 현재 chunk를 요청된 크기의 chunk와 나머지 크기의 chunk로 분할한다. 나머지 chunk를 비우고 요청된 크기의 chunk를 반환한다.

<br>

## Ptmalloc의 보안 검사!

ptmalloc의 보안 검사에 대해 알아보자!

### unlink (doubly linked list)

unlink를 할 small chunk가 이중 연결 리스트에 속하는지 확인한다.

```c
if (__builtin_expect (FD->bk != P || BK->fd != P, 0))
      malloc_printerr (check_action, "corrupted double-linked list", P, AV);
```

연결 해제 할 chunk가 large bin인 경우 이전 검사가 통과되면 다음 검사를 수행해야 한다. 아래 코드는 large bin이 다른 이중 연결 리스트에 속하는지 확인한다.

```c
if (__builtin_expect (P->fd_nextsize->bk_nextsize != P, 0)
 || __builtin_expect (P->bk_nextsize->fd_nextsize != P, 0))
          malloc_printerr (check_action,"corrupted double-linked list (not small)", P, AV);
```

### \_int_malloc

1. 할당 할 victim chunk는 fastbin 연결 목록에 배치된다. 만약 victim chunk의 size가 fastbin index에 맞지 않는다면 메타 데이터가 손상되었음을 의미한다. (결국 size 에러)

```c
if (__builtin_expect (fastbin_index (chunksize (victim)) != idx, 0))
{
    errstr = "malloc(): memory corruption (fast)";
    errout:
        malloc_printerr (check_action, errstr, chunk2mem (victim), av);
        return NULL;
}
```

<br>

1. bk chunk와 victim chunk(할당할 녀석임)가 동일한 이중 연결 리스트에 속하는지 확인한다. bk chink의 fd pointer가 victime chunk를 가르키지 않으면 small chunk의 이중 연결 리스트가 손상되었음을 의미한다.

```c
if (__glibc_unlikely (bck->fd != victim))
{
     errstr = "malloc(): smallbin double linked list corrupted";
     goto errout;
```

2. unsorted bin을 처리 할 때, victim chunk의 크기가 너무 작거나 클 경우에 검사가 실패한다.

```c
if (__builtin_expect (victim->size <= 2 * SIZE_SZ, 0)
   || __builtin_expect (victim->size > av->system_mem, 0))
   malloc_printerr (check_action, "malloc(): memory corruption", chunk2mem (victim));
```

3. large chunk에서 분할 된 나머지 chunk를 unsorted bin에 삽입할 때 목록의 첫 번째 chunk가 unsorted bin의 헤드를 가르키는지 확인한다.

```c
if (__glibc_unlikely (fwd->bk != bck))
{
     errstr = "malloc(): corrupted unsorted chunks";
     goto errout;
}
 
if (__glibc_unlikely (fwd->bk != bck))
{
     errstr = "malloc(): corrupted unsorted chunks 2";
     goto errout;
}
```

<br>

### \_int_free

1. 해제 할 chunk가 유효한 주소에 있는지 확인한다. chunk가 주소 공간의 최 하단을 초과하는지, 마지막 4(64bit), 3(32bit) bit는 모두 0인지

```c
if (__builtin_expect ((uintptr_t) p > (uintptr_t) -size, 0)
     || __builtin_expect (misaligned_chunk (p), 0))
{
    errstr = "free(): invalid pointer";
    errout:
      if (!have_lock && locked)
         (void) mutex_unlock (&av->mutex);
      malloc_printerr (check_action, errstr, chunk2mem (p), av);
      return;
```

<br>

1. chunk의 크기가 유효한지 확인한다. 최소 size보다 큰지, 마지막 4 또는 3 bit가 모두 0이 아닌지

```c
if (__glibc_unlikely (size < MINSIZE || !aligned_OK (size)))
{
    errstr = "free(): invalid size";
    goto errout;
}
```

2. fastbin에 삽입 할 chunk의 크기가 유효한지 확인한다.

```c
if (chunk_at_offset (p, size)->size <= 2 * SIZE_SZ
     || chunksize (chunk_at_offset (p, size)) >= av->system_mem)
{
    errstr = "free(): invalid next size (fast)";
    goto errout;
}
```

3. fastbin의 첫 번째 chunk가 삽입 할 현재 chunk가 아닌지 확인한다.

```c
if (__builtin_expect (old == p, 0))
{
     errstr = "double free or corruption (fasttop)";
     goto errout;
}
```

double free error

4. fastbin에서 첫 번째 chunk의 크기가 삽입 될 현재 chunk의 크기와 동일한 지 확인한다.

```C
if (have_lock && old != NULL && __builtin_expect (old_idx != idx, 0))
{
     errstr = "invalid fastbin entry (free)";
     goto errout;
}
```

5. 해제 될 chunk가 top chunk인지 확인한다.

```c
if (__glibc_unlikely (p == av->top))
{
     errstr = "double free or corruption (top)";
     goto errout;
}
```

6. 다음 인접한 chunk가 현재 heap의 크기를 초과하지 않는지 확인한다.

```c
if (__builtin_expect (contiguous (av) 
     && (char *) nextchunk >= ((char *) av->top + chunksize(av->top)), 0))
{
     errstr = "double free or corruption (out)";
     goto errout;
}
```

7. 다음 인접한 chunk의 P bit가 설정되어 있는지 확인한다.

```c
if (__glibc_unlikely (!prev_inuse(nextchunk)))
{
     errstr = "double free or corruption (!prev)";
     goto errout;
}
```

8. 다음 인접한 chunk의 크기가 유효한지 확인한다.

```c
if (__builtin_expect (nextchunk->size <= 2 * SIZE_SZ, 0)
     || __builtin_expect (nextsize >= av->system_mem, 0))
{
     errstr = "free(): invalid next size (normal)";
     goto errout;
}
```

9. chunk를 unsorted bin에 삽입할 때 unsorted bin의 첫 번째 chunk의 bk가 unsorted bin의 head를 가르키고 있는지 확인한다.

```c
if (__glibc_unlikely (fwd->bk != bck))
{
     errstr = "free(): corrupted unsorted chunks";
     goto errout;
}
```

