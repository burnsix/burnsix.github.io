---
title: Ptmalloc 1
date: 2018-12-30
---

아주 좋은 자료가 있기 때문에! 이걸 번역하면서 배워보도록 하고자 한다. 물론 번역만 하는 느낌이 강하겠지만.. 일단 열심히 읽었다는 사실도 주요하당..

Ptmalloc은 libc에서 사용되는 메모리 할당 자이다. libc 2.25의 소스 코드로 알아 보도록 하자!

### Ptmalloc chunk

Ptmalloc의 메모리 관리 기본 단위는 malloc_chunk이다. 6개의 메타 데이터 필드로 구성되며 32bit 는 4바이트 64bit는 8바이트이다.

```c
#ifndef INTERNAL_SIZE_T
# define INTERNAL_SIZE_T size_t
#endif
#define SIZE_SZ (sizeof (INTERNAL_SIZE_T))
 
struct malloc_chunk;
typedef struct malloc_chunk* mchunkptr;
 
struct malloc_chunk {
 
  INTERNAL_SIZE_T      mchunk_prev_size;  /* Size of previous chunk (if free).  */
  INTERNAL_SIZE_T      mchunk_size;       /* Size in bytes, including overhead. */
 
  struct malloc_chunk* fd;         /* double links -- used only if free. */
  struct malloc_chunk* bk;
 
  /* Only used for large blocks: pointer to next larger size.  */
  struct malloc_chunk* fd_nextsize; /* double links -- used only if free. */
  struct malloc_chunk* bk_nextsize;
};
```

이것이 바로 chunk 구조체 이다. ptmalloc에서 chunk는 메모리 관리 할당자를 통해 할당 된 메모리 영역을 말하고 메타 데이터 및 응용 프로그램 데이터를 저장하는데 사용 된다.

malloc_chunk_size의 마지막 3bit 즉 flag(언제나 강조해 온 녀석이다.)

A : chunk가 main arena 영역이 아닐 때

M : chunk가 mmap으로 할당된 녀석일 때

P : 이전 chunk의 사용 여부 (사용중이면 설정됨)

기본적인 CTF 문제 같은 경우 prev_inuse flag 즉 P에 집중되게 된다. 

```c
/* conversion from malloc headers to user pointers, and back */
#define chunk2mem(p)   ((void*)((char*)(p) + 2*SIZE_SZ))
#define mem2chunk(mem) ((mchunkptr)((char*)(mem) - 2*SIZE_SZ))
 
/* size field is or'ed with PREV_INUSE when previous adjacent chunk in use */
#define PREV_INUSE 0x1
/* extract inuse bit of previous chunk */
#define prev_inuse(p)       ((p)->mchunk_size & PREV_INUSE)
/* size field is or'ed with IS_MMAPPED if the chunk was obtained with mmap() */
#define IS_MMAPPED 0x2
/* check for mmap()'ed chunk */
#define chunk_is_mmapped(p) ((p)->mchunk_size & IS_MMAPPED)
/* size field is or'ed with NON_MAIN_ARENA if the chunk was obtained
   from a non-main arena.  This is only set immediately before handing
   the chunk to the user, if necessary.  */
#define NON_MAIN_ARENA 0x4
/* Check for chunk from main arena.  */
#define chunk_main_arena(p) (((p)->mchunk_size & NON_MAIN_ARENA) == 0)
/* Mark a chunk as not being on the main arena.  */
#define set_non_main_arena(p) ((p)->mchunk_size |= NON_MAIN_ARENA)
 
#define SIZE_BITS (PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)
/* Get size, ignoring use bits */
#define chunksize(p) (chunksize_nomask (p) & ~(SIZE_BITS))
/* Like chunksize, but do not mask SIZE_BITS.  */
#define chunksize_nomask(p)         ((p)->mchunk_size)
/* Ptr to next physical malloc_chunk. */
#define next_chunk(p) ((mchunkptr) (((char *) (p)) + chunksize (p)))
/* Size of the chunk below P.  Only valid if prev_inuse (P).  */
#define prev_size(p) ((p)->mchunk_prev_size)
/* Set the size of the chunk below P.  Only valid if prev_inuse (P).  */
#define set_prev_size(p, sz) ((p)->mchunk_prev_size = (sz))
/* Ptr to previous physical malloc_chunk.  Only valid if prev_inuse (P).  */
#define prev_chunk(p) ((mchunkptr) (((char *) (p)) - prev_size (p)))
/* Treat space at ptr + offset as a chunk */
#define chunk_at_offset(p, s)  ((mchunkptr) (((char *) (p)) + (s)))
/* extract p's inuse bit */
#define inuse(p)                                  \
  ((((mchunkptr) (((char *) (p)) + chunksize (p)))->mchunk_size) & PREV_INUSE)
/* set/clear chunk as being inuse without otherwise disturbing */
#define set_inuse(p)                                  \
  ((mchunkptr) (((char *) (p)) + chunksize (p)))->mchunk_size |= PREV_INUSE
#define clear_inuse(p)                                \
  ((mchunkptr) (((char *) (p)) + chunksize (p)))->mchunk_size &= ~(PREV_INUSE)
/* check/set/clear inuse bits in known places */
#define inuse_bit_at_offset(p, s)                         \
  (((mchunkptr) (((char *) (p)) + (s)))->mchunk_size & PREV_INUSE)
#define set_inuse_bit_at_offset(p, s)                         \
  (((mchunkptr) (((char *) (p)) + (s)))->mchunk_size |= PREV_INUSE)
#define clear_inuse_bit_at_offset(p, s)                       \
  (((mchunkptr) (((char *) (p)) + (s)))->mchunk_size &= ~(PREV_INUSE))
/* Set size at head, without disturbing its use bit */
#define set_head_size(p, s)  ((p)->mchunk_size = (((p)->mchunk_size & SIZE_BITS) | (s)))
/* Set size/use field */
#define set_head(p, s)       ((p)->mchunk_size = (s))
/* Set size at footer (only when chunk is not in use) */
#define set_foot(p, s)       (((mchunkptr) ((char *) (p) + (s)))->mchunk_prev_size = (s))
```

복잡하다..

할당 된 chunk의 경우 이전 인접 chunk가 해제되고 P가 설정되지 않은 경우 이전 chunk의 크기가 설정된다. (prev_size 필드) 그 다음 인접 chunk에서 P가 설정된다. 주요한 점은 현재 chunk가 할당 된 chunk이며 mchunk_prev_size가 응용 프로그램 데이터를 저장하는 데 사용 된다는 것이다.(User data 영역)

```c
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|             Size of previous chunk                            |<= chunk
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|             Size of chunk, in bytes                     |A|M|P|
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|             User data starts here...                          .<= mem
.                                                               .
.             (malloc_usable_size() bytes)                      .
.                                                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|             (size of chunk, but used for application data)    |<= next chunk
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|             Size of next chunk, in bytes                |A|0|1|
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```

해제 된 chunk의 경우 이전 인접 chunk가 해제되고 P가 설정되지 않은 경우 이전 chunk의 크기가 설정된다. 그 다음 인접 chunk에서 P는 설정이 해제되고 mchunk_prev_size는 현재 chunk의 크기로 설정된다. fd, bk는 현재 chunk 크기에 의해 결정되고 관리하는 bin에 따라 설정된다.

```c
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|             Size of previous chunk                            |<= chunk
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|             Size of chunk, in bytes                     |A|0|P|
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|             Forward pointer to next chunk in list             |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|             Back pointer to previous chunk in list            |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|             Unused space (may be 0 bytes long)                .
.                                                               .
.                                                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|             Size of chunk, in bytes                           |<= next chunk
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|             Size of next chunk, in bytes                |A|0|0|
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```

Top chunk! 이 녀석의 chunk_size는 현재 main arena의 남은 크기를 나타낸다. 새 크기가 남은 크기보다 크다면 brk() 또는 mmap()이 호출되어 top chunk를 확대한다.

```c
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|             Size of previous chunk                            |<= top chunk
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|             Size of chunk, in bytes                     |A|0|P|
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+                                                               +
|                                                               |
+                                                               +
.                                                               .
.                                                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```

### chunk 관리

Ptmalloc에 있는 malloc chunk를 이해 한 후에 ptmalloc을 통해 chunk를 관리하는 방법에 대해 생각해 볼 수 있다.

ptmalloc에는 해제 된 chunk를 관리하는 4가지 저장소가 있다. fastbin, unsorted bin, small bins, large bins

구조체 malloc_state는 아래 소스 코드와 같이 top chunk pointer, last remainder, fast bins , bins 를 저장하는 데 사용 된다.

```c
struct malloc_state
{
  /* Serialize access.  */
  __libc_lock_define (, mutex);
 
  /* Flags (formerly in max_fast).  */
  int flags;
 
  /* Fastbins */
  mfastbinptr fastbinsY[NFASTBINS];
 
  /* Base of the topmost chunk -- not otherwise kept in a bin */
  mchunkptr top;
 
  /* The remainder from the most recent split of a small request */
  mchunkptr last_remainder;
 
  /* Normal bins packed as described above */
  mchunkptr bins[NBINS * 2 - 2];
 
  /* Bitmap of bins */
  unsigned int binmap[BINMAPSIZE];
 
  /* Linked list */
  struct malloc_state *next;
 
  /* Linked list for free arenas.  Access to this field is serialized
     by free_list_lock in arena.c.  */
  struct malloc_state *next_free;
 
  /* Number of threads attached to this arena.  0 if the arena is on
     the free list.  Access to this field is serialized by
     free_list_lock in arena.c.  */
  INTERNAL_SIZE_T attached_threads;
 
  /* Memory allocated from the system in this arena.  */
  INTERNAL_SIZE_T system_mem;
  INTERNAL_SIZE_T max_system_mem;
};
```

메모리를 보여주는 예제를 가져왔다. 0x804b0a8이 top chunk pointer 이며 fastbinsY는 0xf7fac788에 위치하고 총 10개를 저장할 수 있다. unsorted bin, small bin, large bin 은 bins와 같은 곳에 위치 한다. 0xf7fac7b0!

```c
0xf7fac780: 0x00000000  0x00000001  0x00000000  0x00000000
0xf7fac790: 0x00000000  0x00000000  0x00000000  0x00000000
0xf7fac7a0: 0x00000000  0x00000000  0x00000000  0x00000000
0xf7fac7b0: 0x0804b0a8  0x00000000  0xf7fac7b0  0xf7fac7b0
0xf7fac7c0: 0xf7fac7b8  0xf7fac7b8  0xf7fac7c0  0xf7fac7c0
0xf7fac7d0: 0xf7fac7c8  0xf7fac7c8  0xf7fac7d0  0xf7fac7d0
0xf7fac7e0: 0xf7fac7d8  0xf7fac7d8  0xf7fac7e0  0xf7fac7e0
0xf7fac7f0: 0xf7fac7e8  0xf7fac7e8  0xf7fac7f0  0xf7fac7f0
0xf7fac800: 0xf7fac7f8  0xf7fac7f8  0xf7fac800  0xf7fac800
0xf7fac810: 0xf7fac808  0xf7fac808  0xf7fac810  0xf7fac810
```

<br>

내부 malloc에 대한 그림!

![20171202001](/Users/bskim/Desktop/20171202001.png)

으 너무 복잡하다.. 일단 넣기만 하겠다.

<br>

### malloc_init_state

```c
#define NBINS             128
#define NSMALLBINS         64
#define SMALLBIN_WIDTH    MALLOC_ALIGNMENT
#define SMALLBIN_CORRECTION (MALLOC_ALIGNMENT > 2 * SIZE_SZ)
#define MIN_LARGE_SIZE    ((NSMALLBINS - SMALLBIN_CORRECTION) * SMALLBIN_WIDTH)
#define in_smallbin_range(sz)  \
  ((unsigned long) (sz) < (unsigned long) MIN_LARGE_SIZE)
 
#ifndef DEFAULT_MXFAST
#define DEFAULT_MXFAST     (64 * SIZE_SZ / 4)
#endif
 
#define set_max_fast(s) \
  global_max_fast = (((s) == 0)                           \
                     ? SMALLBIN_WIDTH : ((s + SIZE_SZ) & ~MALLOC_ALIGN_MASK))
#define get_max_fast() global_max_fast
 
malloc_init_state (mstate av)
{
  int i;
  mbinptr bin;
 
  /* Establish circular links for normal bins */
  for (i = 1; i fd = bin->bk = bin;
    }
 
  set_noncontiguous (av);
  if (av == &main_arena)
    set_max_fast (DEFAULT_MXFAST);
  av->flags |= FASTCHUNKS_BIT;
 
  av->top = initial_top (av);
}
```

맨 처음 malloc_init_state가 호출되어 malloc_state를 초기화 한다. 이 과정에서 bin의 fd, bk pointer는 bin으로(?) 설정된다. 그리고 global_max_fast(fastbin에 저장되는 최대 size) 는 os bit에 맞게 0x40, 0x80으로 설정된다.

<br>

### malloc_consolidate

malloc_consolidate는 해제 된 chunk를 fastbins에 병합하고 unsorted bin으로 이동하려 한다. fastbin에서 해제 된 chunk를 검색 한 후 병합 순서는 다음과 같다.

인접한 이전 chunk가 사용중이라면 현재 chunk를 이전 chunk와 병합

인접한 다음 chunk가 top chunk라면 현재 chunk를 top chunk로 설정하고 chunk_size를 수정한다. 아니라면 다음 단계!

인접한 다음 chunk가 사용중 이라면 현재 chunk를 unsorted bin으로 이동하고 다음 chunk의 P bit를 해제 시킨다. 아니라면, 다음 chunk를 현재 chunk와 병합하고, 현재 chunk를 unsorted bin으로 이동 시키고 인접 chunk의 P bit를 해제 시킨다.

```c
/*
  ------------------------- malloc_consolidate -------------------------
 
  malloc_consolidate is a specialized version of free() that tears
  down chunks held in fastbins.  Free itself cannot be used for this
  purpose since, among other things, it might place chunks back onto
  fastbins.  So, instead, we need to use a minor variant of the same
  code.
 
  Also, because this routine needs to be called the first time through
  malloc anyway, it turns out to be the perfect place to trigger
  initialization code.
*/
 
static void malloc_consolidate(mstate av)
{
  mfastbinptr*    fb;                 /* current fastbin being consolidated */
  mfastbinptr*    maxfb;              /* last fastbin (for loop control) */
  mchunkptr       p;                  /* current chunk being consolidated */
  mchunkptr       nextp;              /* next chunk to consolidate */
  mchunkptr       unsorted_bin;       /* bin header */
  mchunkptr       first_unsorted;     /* chunk to link to */
 
  /* These have same use as in free() */
  mchunkptr       nextchunk;
  INTERNAL_SIZE_T size;
  INTERNAL_SIZE_T nextsize;
  INTERNAL_SIZE_T prevsize;
  int             nextinuse;
  mchunkptr       bck;
  mchunkptr       fwd;
 
  /*
    If max_fast is 0, we know that av hasn't
    yet been initialized, in which case do so below
  */
 
  if (get_max_fast () != 0) {
    clear_fastchunks(av);
 
    unsorted_bin = unsorted_chunks(av);
 
    /*
      Remove each chunk from fast bin and consolidate it, placing it
      then in unsorted bin. Among other reasons for doing this,
      placing in unsorted bin avoids needing to calculate actual bins
      until malloc is sure that chunks aren't immediately going to be
      reused anyway.
    */
 
    maxfb = &fastbin (av, NFASTBINS - 1);
    fb = &fastbin (av, 0);
    do {
      p = atomic_exchange_acq (fb, NULL);
      if (p != 0) {
    do {
      check_inuse_chunk(av, p);
      nextp = p->fd;
 
      /* Slightly streamlined version of consolidation code in free() */
      size = chunksize (p);
      nextchunk = chunk_at_offset(p, size);
      nextsize = chunksize(nextchunk);
 
      if (!prev_inuse(p)) {
        prevsize = prev_size (p);
        size += prevsize;
        p = chunk_at_offset(p, -((long) prevsize));
        unlink(av, p, bck, fwd);
      }
 
      if (nextchunk != av->top) {
        nextinuse = inuse_bit_at_offset(nextchunk, nextsize);
 
        if (!nextinuse) {
          size += nextsize;
          unlink(av, nextchunk, bck, fwd);
        } else
          clear_inuse_bit_at_offset(nextchunk, 0);
 
        first_unsorted = unsorted_bin->fd;
        unsorted_bin->fd = p;
        first_unsorted->bk = p;
 
        if (!in_smallbin_range (size)) {
          p->fd_nextsize = NULL;
          p->bk_nextsize = NULL;
        }
 
        set_head(p, size | PREV_INUSE);
        p->bk = unsorted_bin;
        p->fd = first_unsorted;
        set_foot(p, size);
      }
 
      else {
        size += nextsize;
        set_head(p, size | PREV_INUSE);
        av->top = p;
      }
 
    } while ( (p = nextp) != 0);
 
      }
    } while (fb++ != maxfb);
  }
  else {
    malloc_init_state(av);
    check_malloc_state(av);
  }
}
```

<br>

### \__int_malloc

\__libc_malloc 은 bins 또는 main arena에서 응용 프로그램에 요청 된 chunk를 반환하는 함수이다. 

```c
checked_request2size (bytes, nb);
```

할당자는 요청 된 크기를 실제 할당 된 chunk 크기로 먼저 변환한다. 그 다음 할당자는 다음 순서로 요청 된 chunk를 얻으려고 한다. fastbin, unsorted bin, small bin, large bin, top chunk 

<br>

### Fastbin

```c
/*
   If the size qualifies as a fastbin, first check corresponding bin.
   This code is safe to execute even if av is not yet initialized, so we
   can try it without checking, which saves some time on this fast path.
*/
 
if ((unsigned long) (nb) fd, victim))!= victim);
    if (victim != 0)
    {
         if (__builtin_expect (fastbin_index (chunksize (victim)) != idx, 0))
         {
              errstr = "malloc(): memory corruption (fast)";
            errout:
              malloc_printerr (check_action, errstr, chunk2mem (victim), av);
              return NULL;
         }
         check_remalloced_chunk (av, victim, nb);
         void *p = chunk2mem (victim);
         alloc_perturb (p, bytes);
         return p;
     }
}
```

크기가 global_max_fast 보다 작거나 같으면 할당자는 적절한 크기의 chunk를 찾기 위해 fastbin을 검색 한다. fastbin에 대한 index는 chunk의 크기로 결정된다.

### Small bin

```c
/*
   If a small request, check regular bin.  Since these "smallbins"
   hold one size each, no searching within bins is necessary.
   (For a large request, we need to wait until unsorted chunks are
   processed to find best fit. But for small ones, fits are exact
   anyway, so we can check now, which is faster.)
 */
 
if (in_smallbin_range (nb))
  {
    idx = smallbin_index (nb);
    bin = bin_at (av, idx);
 
    if ((victim = last (bin)) != bin)
      {
        if (victim == 0) /* initialization check */
          malloc_consolidate (av);
        else
        {
            bck = victim->bk;
        if (__glibc_unlikely (bck->fd != victim))
            {
                errstr = "malloc(): smallbin double linked list corrupted";
                goto errout;
            }
            set_inuse_bit_at_offset (victim, nb);
            bin->bk = bck;
            bck->fd = bin;
 
            if (av != &main_arena)
      set_non_main_arena (victim);
            check_malloced_chunk (av, victim, nb);
            void *p = chunk2mem (victim);
            alloc_perturb (p, bytes);
            return p;
         }
      }
  }
```

small bin 또한, chunk 크기에 의해 결정된다. 해당 small bin을 식별한 후 할당할 때 small bin의 가장 첫 번째에 들어있는 free chunk를 제거하여 반환하려 한다.

### Unsorted bin

```c
while ((victim = unsorted_chunks (av)->bk) != unsorted_chunks (av))
{
     bck = victim->bk;
     if (__builtin_expect (chunksize_nomask (victim)  av->system_mem, 0))
        malloc_printerr (check_action, "malloc(): memory corruption",
                             chunk2mem (victim), av);
     size = chunksize (victim);
 
     /*
         If a small request, try to use last remainder if it is the
         only chunk in unsorted bin.  This helps promote locality for
         runs of consecutive small requests. This is the only
         exception to best-fit, and applies only when there is
         no exact fit for a small chunk.
     */
 
     if (in_smallbin_range (nb) &&
         bck == unsorted_chunks (av) &&
         victim == av->last_remainder &&
         (unsigned long) (size) > (unsigned long) (nb + MINSIZE))
     {
         /* split and reattach remainder */
         remainder_size = size - nb;
         remainder = chunk_at_offset (victim, nb);
         unsorted_chunks (av)->bk = unsorted_chunks (av)->fd = remainder;
         av->last_remainder = remainder;
         remainder->bk = remainder->fd = unsorted_chunks (av);
         if (!in_smallbin_range (remainder_size))
         {
            remainder->fd_nextsize = NULL;
            remainder->bk_nextsize = NULL;
         }
 
         set_head (victim, nb | PREV_INUSE |
                  (av != &main_arena ? NON_MAIN_ARENA : 0));
         set_head (remainder, remainder_size | PREV_INUSE);
         set_foot (remainder, remainder_size);
 
         check_malloced_chunk (av, victim, nb);
         void *p = chunk2mem (victim);
         alloc_perturb (p, bytes);
         return p;
      }
 
      /* remove from unsorted list */
      unsorted_chunks (av)->bk = bck;
      bck->fd = unsorted_chunks (av);
 
      /* Take now instead of binning if exact fit */
 
      if (size == nb)
      {
          set_inuse_bit_at_offset (victim, size);
          if (av != &main_arena)
             set_non_main_arena (victim);
          check_malloced_chunk (av, victim, nb);
          void *p = chunk2mem (victim);
          alloc_perturb (p, bytes);
          return p;
       }
 
       /* place chunk in bin */
 
       if (in_smallbin_range (size))
       {
           victim_index = smallbin_index (size);
           bck = bin_at (av, victim_index);
           fwd = bck->fd;
       }
       else
       {
           victim_index = largebin_index (size);
           bck = bin_at (av, victim_index);
           fwd = bck->fd;
 
           /* maintain large bins in sorted order */
           if (fwd != bck)
           {
               /* Or with inuse bit to speed comparisons */
               size |= PREV_INUSE;
               /* if smaller than smallest, bypass loop below */
               assert (chunk_main_arena (bck->bk));
               if ((unsigned long) (size)
              bk))
               {
                   fwd = bck;
                   bck = bck->bk;
 
                   victim->fd_nextsize = fwd->fd;
                   victim->bk_nextsize = fwd->fd->bk_nextsize;
                   fwd->fd->bk_nextsize = victim->bk_nextsize->fd_nextsize = victim;
               }
               else
               {
                   assert (chunk_main_arena (fwd));
                   while ((unsigned long) size fd_nextsize;
               assert (chunk_main_arena (fwd));
                   }
 
                   if ((unsigned long) size
                == (unsigned long) chunksize_nomask (fwd))
                       /* Always insert in the second position.  */
                       fwd = fwd->fd;
                   else
                   {
                       victim->fd_nextsize = fwd;
                       victim->bk_nextsize = fwd->bk_nextsize;
                       fwd->bk_nextsize = victim;
                       victim->bk_nextsize->fd_nextsize = victim;
                   }
                   bck = fwd->bk;
                }
            }
            else
                victim->fd_nextsize = victim->bk_nextsize = victim;
       }
 
       mark_bin (av, victim_index);
       victim->bk = bck;
       victim->fd = fwd;
       fwd->bk = victim;
       bck->fd = victim;
 
#define MAX_ITERS       10000
       if (++iters >= MAX_ITERS)
          break;
```

상당히 길다.

첫 번째 chunk가 다음 조건을 만족하면 할당자가 unsorted bin 을 반복한다. 이 chunk는 요청 된 크기의 chunk와 나머지 chunk로 분할된다. 이 때 나머지 chunk는 다시 unsorted bin에 들어가게 된다.

1. 요청한 크기가 small chunk 크기
2. unsorted bin의 유일한 chunk 일 때
3. 마지막으로 남은 chunk 일 때
4. 분할 후 나머지 chunk가 충분히 클 때



unsorted chunk의 크기가 요청 된 크기에 정확하게 맞으면 chunk를 반환한다. 그렇지 않으면 unsorted bin에 대한 반복은 unsorted chunk의 상태를 계속 확인? 검색? 한다.

1. unsorted chunk가 small size 범위에 있으면 해당 small bin에 들어가게 된다. 그 후에 unsorted chunk에 대해 위 프로세스를 반복한다.
2. 그렇지 않은 경우, unsorted chunk가 large size에 있고 해당 large bin이 비어있다면 (bck == fwd), unsorted chunk가 해당 large bin으로 직접 들어가게 된다. 그 다음 또 반복
3. 또 그렇지 않은 경우, large size에 있지만 해당 large bin이 비어 있지 않을 경우, unsorted chunk는 크기 순서를 내림차순으로 해당 large bin에 삽입된다. (large bin attack에 이용 한다.)



결국 unsorted bin의 unsorted chunk는 적합한 chunk를 반환할 수 없다. 즉, 요청 된 chunk를 제공 할 unsorted chunk또는 small bin이 없다.

### Large bin

```c
/*
     If a large request, scan through the chunks of current bin in
     sorted order to find smallest that fits.  Use the skip list for this.
*/
 
if (!in_smallbin_range (nb))
{
   bin = bin_at (av, idx);
   /* skip scan if empty or largest chunk is too small */
   if ((victim = first (bin)) != bin
        && (unsigned long) chunksize_nomask (victim)>= (unsigned long) (nb))
   {
        victim = victim->bk_nextsize;
        while (((unsigned long) (size = chunksize (victim)) bk_nextsize;
 
        /* Avoid removing the first entry for a size so that the skip
             list does not have to be rerouted.  */
        if (victim != last (bin)
              && chunksize_nomask (victim)== chunksize_nomask (victim->fd))
           victim = victim->fd;
 
         remainder_size = size - nb;
         unlink (av, victim, bck, fwd);
 
              /* Exhaust */
         if (remainder_size fd;
          if (__glibc_unlikely (fwd->bk != bck))
              {
                    errstr = "malloc(): corrupted unsorted chunks";
                    goto errout;
              }
              remainder->bk = bck;
              remainder->fd = fwd;
              bck->fd = remainder;
              fwd->bk = remainder;
              if (!in_smallbin_range (remainder_size))
              {
                   remainder->fd_nextsize = NULL;
                   remainder->bk_nextsize = NULL;
              }
              set_head (victim, nb | PREV_INUSE |
                       (av != &main_arena ? NON_MAIN_ARENA : 0));
              set_head (remainder, remainder_size | PREV_INUSE);
              set_foot (remainder, remainder_size);
         }
         check_malloced_chunk (av, victim, nb);
         void *p = chunk2mem (victim);
         alloc_perturb (p, bytes);
         return p;
   }
}
```

large bin에 large chunk가 없거나 large bin의 첫 번째 large chunk의 크기가 요청 된 크기보다 작은 경우는 할당자는 다음 단계를 실행한다. (만약 그렇지 않다면 현재 large bin에서 하나의 chunk를 찾는다.)

large bin 에서 large chunk를 검색하면 가장 적합한 규칙, 즉 크기가 요청 된 크기보다 큰 가장 작은 chunk가 반환된다. large chunk를 발견 한 후 쪼개서 나머지 남은 크기를 계산하고 나머지 크기가 MIN_SIZE보다 작으면 전체 chunk를 반환 값으로 반환한다. 그렇지 않다면 현재 chunk를 분할하고 나머지 chunk는 Unsorted bin에 들어가게 된다.

### Top chunk splitting

```c
use_top:
/*
    If large enough, split off the chunk bordering the end of memory
    (held in av->top). Note that this is in accord with the best-fit
    search rule.  In effect, av->top is treated as larger (and thus
    less well fitting) than any other available chunk since it can
    be extended to be as large as necessary (up to system
    limitations).
 
    We require that av->top always exists (i.e., has size >=
    MINSIZE) after initialization, so if it would otherwise be
    exhausted by current request, it is replenished. (The main
    reason for ensuring it exists is that we may need MINSIZE space
    to put in fenceposts in sysmalloc.)
*/
victim = av->top;
size = chunksize (victim);
 
if ((unsigned long) (size) >= (unsigned long) (nb + MINSIZE))
{
     remainder_size = size - nb;
     remainder = chunk_at_offset (victim, nb);
     av->top = remainder;
     set_head (victim, nb | PREV_INUSE |
               (av != &main_arena ? NON_MAIN_ARENA : 0));
     set_head (remainder, remainder_size | PREV_INUSE);
 
     check_malloced_chunk (av, victim, nb);
     void *p = chunk2mem (victim);
     alloc_perturb (p, bytes);
     return p;
}
```

top chunk가 충분히 크고 위의 모든 프로세스가 적합한 chunk를 반환할 수 없는 경우 top chunk는 요청 된 chunk로 분할 되고 나머지 chunk로 top chunk를 다시 설정하게 된다!

<br>

### Malloc에 사용되는 일반적인 MACRO

```c
					X86	 X86-64
SIZE_SZ	 			 4	   8
MIN_CHUNK_SIZE		 16	   32
MALLOC_ALIGNMENT	 8	   16
MALLOC_ALIGN_MASK	 7	   15 명
NBINS				128 자  128 자
NFASTBINS			 10	   10
NSMALLBINS			 64 개  64 개
SMALLBIN_WIDTH		 8	   16
DEFAULT_MXFAST		 64 개  128 자
MAX_FAST_SIZE		 80	    160
MIN_LARGE_SIZE		 512	1024
```

이제 각 bin의 특징들을 알아보자(이것만 몇번을 쓰는지!!!!)

<br>

### Fastbin

1. Single linked list
2. 32 bit는 0x10 ~ 0x40, 64bit는 0x20 ~ 0x80
3. fastbin에서 현재 chunk의 인접 chunk의 P bit는 설정 해제되지 않는다.
4. fastbin을 검색할 때 할당자는 LIFO 규칙을 따른다.

```c
#include
#include
 
int main()
{
    char *p1, *p2, *p3, *p4;
 
    p1 = malloc(0x20);
    p2 = malloc(0x20);
    p3 = malloc(0x20);
    p4 = malloc(0x20);
 
    free(p1);
    free(p2);
    free(p3);
 
    return 0;
}
 
/*
(gdb) x/20wx 0xf7fac780
0xf7fac780: 0x00000000  0x00000000  0x00000000  0x00000000
0xf7fac790: 0x00000000  0x0804b050  0x00000000  0x00000000
0xf7fac7a0: 0x00000000  0x00000000  0x00000000  0x00000000
0xf7fac7b0: 0x0804b0a0  0x00000000  0xf7fac7b0  0xf7fac7b0
0xf7fac7c0: 0xf7fac7b8  0xf7fac7b8  0xf7fac7c0  0xf7fac7c0
(gdb) x/12wx 0x0804b050
0x804b050:  0x00000000  0x00000029  0x0804b028  0x00000000
0x804b060:  0x00000000  0x00000000  0x00000000  0x00000000
0x804b070:  0x00000000  0x00000000  0x00000000  0x00000029
(gdb) x/12wx 0x0804b028
0x804b028:  0x00000000  0x00000029  0x0804b000  0x00000000
0x804b038:  0x00000000  0x00000000  0x00000000  0x00000000
0x804b048:  0x00000000  0x00000000  0x00000000  0x00000029
(gdb) x/12wx 0x0804b000
0x804b000:  0x00000000  0x00000029  0x00000000  0x00000000
0x804b010:  0x00000000  0x00000000  0x00000000  0x00000000
0x804b020:  0x00000000  0x00000000  0x00000000  0x00000029
*/
```

이 상황에서 0x20 malloc을 요청하면 0x0804b058 에 user data 영역이 할당된다.

### Unsorted bin

1. double linked list
2. global_max_fast 의 크기보다 커야한다.
3. 할당 할 때 할당자는 unsorted bin의 unsorted chunk를 반복한다. 적합한 chunk를 찾은 후 unsorted chunk에서 chunk를 제거한다.

```c
#include
#include
 
int main()
{
    char *p1, *p2, *p3, *p4;
 
    p1 = malloc(0xa0);
    p2 = malloc(0x30);
    p3 = malloc(0x100);
    p4 = malloc(0x30);
 
    free(p1);
    free(p3);
 
    return 0;
}
 
/*
(gdb) x/20wx 0xf7fac780
0xf7fac780: 0x00000000  0x00000001  0x00000000  0x00000000
0xf7fac790: 0x00000000  0x00000000  0x00000000  0x00000000
0xf7fac7a0: 0x00000000  0x00000000  0x00000000  0x00000000
0xf7fac7b0: 0x0804b220  0x00000000  0x0804b0e0  0x0804b000
0xf7fac7c0: 0xf7fac7b8  0xf7fac7b8  0xf7fac7c0  0xf7fac7c0
(gdb) x/20wx 0x0804b0e0
0x804b0e0:  0x00000000  0x00000109  0x0804b000  0xf7fac7b0
0x804b0f0:  0x00000000  0x00000000  0x00000000  0x00000000
0x804b100:  0x00000000  0x00000000  0x00000000  0x00000000
0x804b110:  0x00000000  0x00000000  0x00000000  0x00000000
0x804b120:  0x00000000  0x00000000  0x00000000  0x00000000
(gdb) x/20wx 0x0804b000
0x804b000:  0x00000000  0x000000a9  0xf7fac7b0  0x0804b0e0
0x804b010:  0x00000000  0x00000000  0x00000000  0x00000000
0x804b020:  0x00000000  0x00000000  0x00000000  0x00000000
0x804b030:  0x00000000  0x00000000  0x00000000  0x00000000
0x804b040:  0x00000000  0x00000000  0x00000000  0x00000000
*/
```

### Small bin

1. double linked list
2. small bin에 있는 chunk의 크기는 512 바이트 보다 작아야 한다.
3. unsorted chunk와 달리 해제 된 chunk는 할당 해제 후 바로 small bin에 삽입되지 않는다. 
4. FIFO

```c
#include
#include
 
int main()
{
    char *p1, *p2, *p3, *p4, *p5, *p6;
 
    p1 = malloc(0xa0);
    p2 = malloc(0x30);
    p3 = malloc(0xa0);
    p4 = malloc(0x30);
    p5 = malloc(0xa0);
    p6 = malloc(0x30);
 
    free(p1);
    free(p3);
    free(p5);
 
    malloc(0x50);
    malloc(0x50);
    malloc(0x50);
 
    return 0;
}
 
/*
(gdb) x/40wx 0xf7fac780
0xf7fac780: 0x00000000  0x00000001  0x00000000  0x00000000
0xf7fac790: 0x00000000  0x00000000  0x00000000  0x00000000
0xf7fac7a0: 0x00000000  0x00000000  0x00000000  0x00000000
0xf7fac7b0: 0x0804b2a0  0x0804b218  0x0804b218  0x0804b218
0xf7fac7c0: 0xf7fac7b8  0xf7fac7b8  0xf7fac7c0  0xf7fac7c0
0xf7fac7d0: 0xf7fac7c8  0xf7fac7c8  0xf7fac7d0  0xf7fac7d0
0xf7fac7e0: 0xf7fac7d8  0xf7fac7d8  0xf7fac7e0  0xf7fac7e0
0xf7fac7f0: 0xf7fac7e8  0xf7fac7e8  0xf7fac7f0  0xf7fac7f0
0xf7fac800: 0x0804b138  0x0804b058  0xf7fac800  0xf7fac800
0xf7fac810: 0xf7fac808  0xf7fac808  0xf7fac810  0xf7fac810
(gdb) x/20wx 0x0804b138
0x804b138:  0x00000000  0x00000051  0x0804b058  0xf7fac7f8
0x804b148:  0x00000000  0x00000000  0x00000000  0x00000000
0x804b158:  0x00000000  0x00000000  0x00000000  0x00000000
0x804b168:  0x00000000  0x00000000  0x00000000  0x00000000
0x804b178:  0x00000000  0x00000000  0x00000000  0x00000000
(gdb) x/20wx 0x0804b058
0x804b058:  0x00000000  0x00000051  0xf7fac7f8  0x0804b138
0x804b068:  0x00000000  0x00000000  0x00000000  0x00000000
0x804b078:  0x00000000  0x00000000  0x00000000  0x00000000
0x804b088:  0x00000000  0x00000000  0x00000000  0x00000000
0x804b098:  0x00000000  0x00000000  0x00000000  0x00000000
*/
```

### Large bin

1. double linked list
2. 512 바이트보다 커야한다.
3. large chunk에서 fwd, bck pointer를 제외하고 fd_nextsize, bk_nextsize는 크기가 다른 chunk(내림차순으로 정렬!)을 나타낸다.
4. small chunk의 마찬가지로 해제 된 chunk가 곧바로 large bin에 삽입되지 않는다.
5. large bin에서 chunk를 검색할 때는 가장 적합한 규칙, 즉 크기가 요청 된 크기보다 큰 가장 작은 chunk를 반환한다.

```c
#include
#include
 
int main()
{
    char *p1, *p2, *p3, *p4, *p5, *p6, *p7, *p8;
 
    p1 = malloc(0x1000);
    p2 = malloc(0x30);
    p3 = malloc(0x1000);
    p4 = malloc(0x30);
    p5 = malloc(0x1000);
    p6 = malloc(0x30);
    p7 = malloc(0x1000);
    p8 = malloc(0x30);
 
    free(p1);
    free(p3);
    free(p5);
    free(p7);
 
    malloc(0x810);
    malloc(0x810);
    malloc(0x840);
    malloc(0x840);
 
    return 0;
}
/*
(gdb) x/200wx 0xf7fac780
0xf7fac780: 0x00000000  0x00000001  0x00000000  0x00000000
0xf7fac790: 0x00000000  0x00000000  0x00000000  0x00000000
0xf7fac7a0: 0x00000000  0x00000000  0x00000000  0x00000000
0xf7fac7b0: 0x0804f100  0x00000000  0x0804b848  0x0804b848
0xf7fac7c0: 0xf7fac7b8  0xf7fac7b8  0xf7fac7c0  0xf7fac7c0
0xf7fac7d0: 0xf7fac7c8  0xf7fac7c8  0xf7fac7d0  0xf7fac7d0
0xf7fac7e0: 0xf7fac7d8  0xf7fac7d8  0xf7fac7e0  0xf7fac7e0
0xf7fac7f0: 0xf7fac7e8  0xf7fac7e8  0xf7fac7f0  0xf7fac7f0
0xf7fac800: 0xf7fac7f8  0xf7fac7f8  0xf7fac800  0xf7fac800
0xf7fac810: 0xf7fac808  0xf7fac808  0xf7fac810  0xf7fac810
0xf7fac820: 0xf7fac818  0xf7fac818  0xf7fac820  0xf7fac820
0xf7fac830: 0xf7fac828  0xf7fac828  0xf7fac830  0xf7fac830
0xf7fac840: 0xf7fac838  0xf7fac838  0xf7fac840  0xf7fac840
0xf7fac850: 0xf7fac848  0xf7fac848  0xf7fac850  0xf7fac850
0xf7fac860: 0xf7fac858  0xf7fac858  0xf7fac860  0xf7fac860
0xf7fac870: 0xf7fac868  0xf7fac868  0xf7fac870  0xf7fac870
0xf7fac880: 0xf7fac878  0xf7fac878  0xf7fac880  0xf7fac880
0xf7fac890: 0xf7fac888  0xf7fac888  0xf7fac890  0xf7fac890
0xf7fac8a0: 0xf7fac898  0xf7fac898  0xf7fac8a0  0xf7fac8a0
0xf7fac8b0: 0xf7fac8a8  0xf7fac8a8  0xf7fac8b0  0xf7fac8b0
0xf7fac8c0: 0xf7fac8b8  0xf7fac8b8  0xf7fac8c0  0xf7fac8c0
0xf7fac8d0: 0xf7fac8c8  0xf7fac8c8  0xf7fac8d0  0xf7fac8d0
0xf7fac8e0: 0xf7fac8d8  0xf7fac8d8  0xf7fac8e0  0xf7fac8e0
0xf7fac8f0: 0xf7fac8e8  0xf7fac8e8  0xf7fac8f0  0xf7fac8f0
0xf7fac900: 0xf7fac8f8  0xf7fac8f8  0xf7fac900  0xf7fac900
0xf7fac910: 0xf7fac908  0xf7fac908  0xf7fac910  0xf7fac910
0xf7fac920: 0xf7fac918  0xf7fac918  0xf7fac920  0xf7fac920
0xf7fac930: 0xf7fac928  0xf7fac928  0xf7fac930  0xf7fac930
0xf7fac940: 0xf7fac938  0xf7fac938  0xf7fac940  0xf7fac940
0xf7fac950: 0xf7fac948  0xf7fac948  0xf7fac950  0xf7fac950
0xf7fac960: 0xf7fac958  0xf7fac958  0xf7fac960  0xf7fac960
0xf7fac970: 0xf7fac968  0xf7fac968  0xf7fac970  0xf7fac970
0xf7fac980: 0xf7fac978  0xf7fac978  0xf7fac980  0xf7fac980
0xf7fac990: 0xf7fac988  0xf7fac988  0xf7fac990  0xf7fac990
0xf7fac9a0: 0xf7fac998  0xf7fac998  0xf7fac9a0  0xf7fac9a0
0xf7fac9b0: 0xf7fac9a8  0xf7fac9a8  0xf7fac9b0  0xf7fac9b0
0xf7fac9c0: 0xf7fac9b8  0xf7fac9b8  0xf7fac9c0  0xf7fac9c0
0xf7fac9d0: 0xf7fac9c8  0xf7fac9c8  0xf7fac9d0  0xf7fac9d0
0xf7fac9e0: 0xf7fac9d8  0xf7fac9d8  0xf7fac9e0  0xf7fac9e0
0xf7fac9f0: 0xf7fac9e8  0xf7fac9e8  0xf7fac9f0  0xf7fac9f0
0xf7faca00: 0xf7fac9f8  0xf7fac9f8  0xf7faca00  0xf7faca00
0xf7faca10: 0xf7faca08  0xf7faca08  0xf7faca10  0xf7faca10
0xf7faca20: 0xf7faca18  0xf7faca18  0xf7faca20  0xf7faca20
0xf7faca30: 0xf7faca28  0xf7faca28  0xf7faca30  0xf7faca30
0xf7faca40: 0xf7faca38  0xf7faca38  0xf7faca40  0xf7faca40
0xf7faca50: 0xf7faca48  0xf7faca48  0xf7faca50  0xf7faca50
0xf7faca60: 0xf7faca58  0xf7faca58     {0x0804c858******0x0804e908}
0xf7faca70: 0xf7faca68  0xf7faca68  0xf7faca70  0xf7faca70
0xf7faca80: 0xf7faca78  0xf7faca78  0xf7faca80  0xf7faca80
0xf7faca90: 0xf7faca88  0xf7faca88  0xf7faca90  0xf7faca90
 
(gdb) x/20wx 0x804c858
0x804c858:  0x00000000  0x000007f1  0x0804d898  0xf7faca60
0x804c868:  0x0804e908  0x0804e908  0x00000000  0x00000000
0x804c878:  0x00000000  0x00000000  0x00000000  0x00000000
0x804c888:  0x00000000  0x00000000  0x00000000  0x00000000
0x804c898:  0x00000000  0x00000000  0x00000000  0x00000000
(gdb) x/20wx 0x804d898
0x804d898:  0x00000000  0x000007f1  0x0804e908  0x0804c858
0x804d8a8:  0x00000000  0x00000000  0x00000000  0x00000000
0x804d8b8:  0x00000000  0x00000000  0x00000000  0x00000000
0x804d8c8:  0x00000000  0x00000000  0x00000000  0x00000000
0x804d8d8:  0x00000000  0x00000000  0x00000000  0x00000000
(gdb) x/20wx 0x804e908
0x804e908:  0x00000000  0x000007c1  0xf7faca60  0x0804d898
0x804e918:  0x0804c858  0x0804c858  0x00000000  0x00000000
0x804e928:  0x00000000  0x00000000  0x00000000  0x00000000
0x804e938:  0x00000000  0x00000000  0x00000000  0x00000000
0x804e948:  0x00000000  0x00000000  0x00000000  0x00000000
*/
```

large bin은 살짝 복잡하긴한데 비슷비슷 하고 nextsize 필드만 추가된거긴 하다. 