---
title: Fastbin
date: 2018-12-12 2:00
---

mfastbinptr fastbinsY[NFASTBINS]; // NFASTBINS = 10

fastbin 은 10개의 bin list를 가지고 있고 fastbinsY가 관리 한다. 근데 실제로는 7개의 list만 쓴다(why?)

basic에도 있지만 32bit : 0x10 ~ 0x40, 64bit : 0x20 ~ 0x80 

fastbin 을 이용한 대표적인 공격이 3가지 있다.

### Double free

간단하게 fastbin size 의 chunk를 double free하고, malloc을 여러 번 호출했을 때 동일한 주소를 2번 반환 받을 수 있다.

```c
free(1)
free(0)
free(1)

malloc(8) // 1
malloc(8) // 0
malloc(8) // 1
```

```c
if NOT) minumum <= next chunk's size <= maximum(av->system_mem)
    error ("free(): invalid next size (fast)")
if) the chunk at the top == the chunk we are going to add
    error ("double free or corruption (fasttop)")
if NOT) the size of the chunk at the top == the size of the chunk we are adding.
    error ("invalid fastbin entry (free)")
Insert the chunk at the top of the fastbin list and return.
```

free 제약 조건 

다음 chunk의 size가 안맞으면 invalide next size

그리고 fastbin 의 top에 있는 chunk가 free하는 chunk랑 같으면 (결국 같은거 연속 2번) double free corruption

chunk의 top과 추가하려는 chunk가 같으면 invalid fastbin entry 인 것 같다.(top chunk를 free 하려고 할 때인가..?)

double free를 하고 1번 chunk의 fd를 제약조건(할당 size)에 맞게 덮어씌우면 다음 1번 chunk를 할당할 때 그 곳에 할당된다.

물론 tcache가 아닌 이상 값을 쓸 주소 - chunk header 주소로 할당하도록 해야 한다. 

<br>

### Forging chunks

그냥.. 하나의 fast chunk 를 free 하고 그 free chunk의 fd를 조작할 수 있다면 원하는 주소에 malloc을 할당할 수 있다. (물론 제약조건은 맞춰야함) 이 건 다른 bin들에도 적용되는 내용이다.

```c
if (__builtin_expect (fastbin_index (chunksize (victim)) != idx, 0))                 
          {
             errstr = "malloc(): memory corruption (fast)";                                   
             errout:
             malloc_printerr (check_action, errstr, chunk2mem (victim), av);                  
             return NULL;
          }
```

요청한 크기와 fastbin에서 꺼낸 chunk의 크기가 같아야 한다. (맞추기가 상당히 편하다.)

이것 또한 자주보던 오류이다. 이런 에러메시지들을 알고 있으면 내가 뭘 잘못하고있는지 바로 알 수 있다

<br>

### House of spirit

free 인자 값을 fake chunk로 변조해서 bin list에 fake chunk를 넣는 기법 , fastbin이 선호된다.

```c
if NOT) p is before p+chunksize(p)
    error ("free(): invalid pointer")
  
if NOT) chunk >= MINSIZE OR multiple of MALLOC_ALIGNMENT 
    error ("free(): invalid size")
   
if) chunk's size == fastbin range 
    if NOT) minumum <= next chunk's size <= maximum(av->system_mem) 
        error ("free(): invalid next size (fast)")
    if) the chunk at the top == the chunk we are going to add
        error ("double free or corruption (fasttop)")
    if NOT) the size of the chunk at the top == the size of the chunk we are adding.
        error ("invalid fastbin entry (free)")
    Insert the chunk at the top of the fastbin list and return.
  
if) chunk is not mmapped
    if) the chunk == top chunk
        error ("double free or corruption (top)")
    if NOT) next chunk is within the boundaries of the arena
        error ("double free or corruption (out)")
    if NOT) next chunk's PREVIOUS_IN_USE bit is marked
        error ("double free or corruption (!prev)")
    if NOT) minumum <= next chunk's size <= maximum(av->system_mem)
        error ("free(): invalid next size (normal)")
   
    if) previous chunk is not in use
        unlink(previous chunk)
    if) next chunk != top chunk
        if) next chunk is not in use
            unlink(next chunk)
        Merge the chunk with previous or next, if free
        if NOT) unsorted_chunks(av)->fd->bk == unsorted_chunks(av)
            error ("free(): corrupted unsorted chunks")
        Add it to the head of unsorted bin
    else) // not top chunk
        Merge the chunk into a single top chunk
else)
    call munmap_chunk
```

fake chunk로 free할 때 제약 조건이다. 굉장히 많은 오류가 보이는데.. 기억해두자

free의 p 가 이전 before p + chunksize(p)와 같지 않으면 free(): invaild pointer 

chunk가 최소 크기 아니면 multiple of MALLOC_ALIGNMENT(ㅇ..이건 뭔지 모르겠다) 보다 작다면 free(): invaild size

next chunk size가 최소크기 < size < 128kb이 아니면 free(): invalid next size (fast)

mmap으로 만들어진 chunk가 아닐 때 chunk == top chunk 면 double free c(top)

다음 chunk가 arena 안에 있지 않으면 double free c(out)

다음 chunk의 prev_inuse flag 가 설정되어 있지 않다면 double free c(!prev)

이전 chunk가 사용중이 아니라면 unlink 매크로가 호출된다.

다음 chunk가 top chunk가 아니고 다음 chunk가 사용중이 아니라면 unlink 매크로가 호출된다.

unsorted_chunks(av) -> fd -> bk != unsorted_chunks(av) 라면 free(): corrupted unsorted chunks

생각보다 발생할 수 있는 오류가 많다.. 역시나,, 틀린부분은 지적해주시길 바랍니다!